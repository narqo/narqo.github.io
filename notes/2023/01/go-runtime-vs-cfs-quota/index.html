<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Go runtime vs CFS quota - Vladimir Varankin</title><link rel=canonical href=https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/><meta property="og:title" content="Go runtime vs CFS quota"><meta property="og:description" content="The Go runtime isn't aware if it runs inside a container under the resource constraints (CPU or memory). A mismatch in what the application thinks is has, and what the OS allows to use, can lead to the poor performance of the application after the unexpected throttling."><meta property="og:type" content="article"><meta property="og:url" content="https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/"><meta property="article:section" content="notes"><meta property="article:published_time" content="2023-01-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-12T00:00:00+00:00"><style>:root{--background-color:#fff;--text-color:rgb(19, 19, 19);--text-underline-color:rgba(19, 19, 19, 0.5);--header-color:#111;--hr-color:rgb(143, 150, 163);--link-color:rgb(0, 16, 161);--link-underline-color:rgba(0, 16, 161, 0.3);--link-active-color:rgb(231, 19, 19);--link-active-underline-color:rgba(231, 19, 19, 0.7);--tag-color:rgb(85, 63, 63);--tag-underline-color:rgba(85, 63, 63, 0.5)}html{font-size:16px;height:100%;margin:0;padding:0}body{background:var(--background-color);color:var(--text-color);display:grid;grid-template-rows:auto 1fr auto;font-family:Charter,Georgia,serif;font-size:1.1rem;line-height:1.3;margin:5px 1%;margin:5px max(7px,1%);margin:5px clamp(7px,1.5vw,14px);min-height:calc(100vh - 10px)}h1,h2,h3,h4,h5,h6{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1;margin:1.5em 0 .7em}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color);text-decoration-thickness:.04em;text-underline-offset:.1em}a:hover,a:active{color:#be0000;color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}ul,ol{box-sizing:border-box;max-width:760px;padding:0}ol{padding-left:1.2em}ul>li{list-style:none;margin:.5em 0}figure{margin:0;margin-block-start:1em;margin-block-end:1em;padding:0}figcaption{font-size:16px;font-style:italic}pre{line-height:1.1}code{font-family:sf mono,Menlo,Consolas,monospace;font-size:16px}pre code{font-size:14px;tab-size:2}@media screen and (min-device-width:900px){pre{margin:2em 1em}pre code{font-size:15px;tab-size:4}}hr{color:var(--hr-color);border:none;margin:.5em 0;width:90%}hr::after{content:'¶';display:block;font-size:14px;text-align:center}.site-nav{display:flex;flex-wrap:wrap;letter-spacing:.3em;padding-bottom:16px}.site-nav a,.site-nav span{margin-right:.6em;letter-spacing:0}.site-nav-item-active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.site-content{font-size:19px;max-width:940px}.site-content img{max-width:100%;max-width:calc(100vw - 15px)}.site-content pre{max-width:calc(100vw - 1em);overflow:visible;overflow-x:scroll}@media screen and (min-width:900px){.site-content pre{max-width:calc(100vw - 4em);overflow-x:visible}}.site-footer{font-size:14px;margin:50px 0 0}.site-footer a{color:var(--text-color);text-decoration-color:inherit;text-decoration-color:var(--text-underline-color)}.main-head{display:flex;align-items:baseline;gap:8px}.main-head-meta{font-size:16px;margin:0;padding:0}.main-head-meta a{color:var(--text-color);text-decoration-color:inherit;text-decoration-color:var(--text-underline-color);margin:0 5px 0 0}.main-head-meta a:hover,.main-head-meta a:active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.article{margin:0 0 50px}.article:last-child{margin-bottom:0}.section-head{font-size:28px}.section-head h1,.section-head h2{font-size:1em;margin-top:1em}.section-head h2{margin-bottom:0}.snippet{margin:0 0 40px}.snippet:last-of-type{margin:0}.snippet p{margin:0 0 .3em}.snippet-head h2{font-size:21px;margin:1em 0 .2em}.meta{font-size:14px;line-height:1;padding:5px 0 0}.tag{color:var(--tag-color);text-decoration-color:var(--tag-underline-color);margin:0 0 0 7px;text-transform:lowercase}.meta-topics-list{line-height:1.4;padding:34px 0 0}.meta-topics-list .tag{display:inline-block;margin:0 1ex 0 0}.pagination{display:flex;flex-wrap:nowrap}.page-item{display:inline-block;line-height:32px;margin-right:1em}.glitch:before{background:var(--background-color);position:absolute;content:attr(data-text);clip:rect(0,900px,0,0);animation:glitch-anim 2s infinite linear alternate-reverse;margin-left:-5px;text-shadow:1px 0 red}@media(prefers-reduced-motion){.glitch:before{display:none}}@keyframes glitch-anim{0%{clip:rect(3px,9999px,93px,0)}5%{clip:rect(53px,9999px,78px,0)}10%{clip:rect(10px,9999px,75px,0)}15%{clip:rect(32px,9999px,40px,0)}20%{clip:rect(65px,9999px,62px,0)}25%{clip:rect(31px,9999px,14px,0)}30%{clip:rect(94px,9999px,87px,0)}35%{clip:rect(81px,9999px,41px,0)}40%{clip:rect(45px,9999px,50px,0)}45%{clip:rect(82px,9999px,41px,0)}50%{clip:rect(71px,9999px,3px,0)}55%{clip:rect(75px,9999px,60px,0)}60%{clip:rect(20px,9999px,49px,0)}65%{clip:rect(67px,9999px,92px,0)}70%{clip:rect(47px,9999px,55px,0)}75%{clip:rect(63px,9999px,90px,0)}80%{clip:rect(70px,9999px,92px,0)}85%{clip:rect(41px,9999px,60px,0)}90%{clip:rect(56px,9999px,79px,0)}95%{clip:rect(21px,9999px,68px,0)}100%{clip:rect(15px,9999px,72px,0)}}</style></head><body><nav class=site-nav><a href=/ class=glitch data-text="Vladimir Varankin">Vladimir Varankin</a>
<a href=/notes/ class=site-nav-item-active>Notes</a>
<a href=/publications/>Publications</a>
<span>·</span>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://t.me/varankinv>Telegram</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=site-content><header class=section-head><h1>Go runtime vs CFS quota</h1></header><p>As of today, the Go runtime isn&rsquo;t aware if it runs inside a container under the resource constraints (CPU or memory). The runtime sees the resources available for the container&rsquo;s underlying host OS, e.g. the VM where the container runs, and tries to optimize its behaviour base on what it sees. For container runtimes on Linux, which implements the CPU restrictions via CFS (&ldquo;Completely Fair Scheduler&rdquo;), a mismatch in what the application thinks is has, and what the OS allows to use, can lead to the poor performance of the application after the unexpected throttling.</p><p>For example, a Go application, that runs in a container, constrained with 0.5 CPU, running on a host with 2 CPU, will observe 2 available CPU cores. That is the application&rsquo;s calls to <a href=https://pkg.go.dev/runtime#NumCPU><code>runtime.NumCPU()</code></a> and <a href=https://pkg.go.dev/runtime#GOMAXPROCS><code>runtime.GOMAXPROCS()</code></a> will get us &ldquo;2&rdquo;. Because the Go runtime is optimized for the maximum utilization of the available compute under the concurrent workload, the goroutines it spawns are distributed to the internal thread pool, created with the assumption of two available CPU cores. This causes the application to throttle after the sum of the time it spend on the CPU cores per CFS period become equals to the quota of the container. With <a href=https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html#management>the default CFS period</a> 100ms, the CFS quota of this container 0.5 CPU, and two threads running on different CPU cores, the application is throttled after 25ms every 100ms.</p><p><em>Go project has an old <a href=https://github.com/golang/go/issues/33803>proposal to make its runtime CFS-aware</a> with more examples in the comments.</em></p><p>Let’s observe this behaviour with a simple Go application:</p><pre tabindex=0><code>func main() {
	done := make(chan struct{})

	go work()
	go work()

	fmt.Println(&#34;Started&#34;)
	&lt;-done
}

func work() {
	for {
		os.ReadFile(&#34;/etc/passwd&#34;)
	}
}
</code></pre><p>We will start the app in a docker container (for all examples here, docker runs inside a Linux VM with 2 vCPU):</p><pre tabindex=0><code>% docker container run --rm -ti test-go-cpu-throttle
Started
</code></pre><p>We collect the Go runtime trace from the app to observe that both &ldquo;work&rdquo; goroutines are scheduled onto the two available procs (P threads), and keep the CPU busy, executing the <code>Read</code> syscalls (tiny orange lines below the coloured bars with the goroutines):</p><figure><img src=/images/2023/trace_0.jpg width=1100></figure><p>Now, for the experiment, let&rsquo;s restrict the container with only 0.5 CPU:</p><pre tabindex=0><code>% docker container run --cpus 0.5 --rm -ti test-go-cpu-throttle
Started
</code></pre><p>The runtime trace shows that the goroutines on both Ps execute the <code>Read</code> syscalls for 25ms, and then for 75ms the goroutines did nothing. Then they executed another bunch of syscalls for 25ms, followed by another 75ms of no work:</p><figure><img src=/images/2023/trace_1.jpg width=1100></figure><p><em>Note that this simple experiment also shows that Go runtime can’t tell us when the application was put off the CPU (i.e. throttled). The runtime trace above shows that for 75ms the goroutines were running but didn’t execute any syscalls. This observation explains why our test application uses <code>os.ReadFile</code>: this is so we could clearly differentiate from the trace the period when the application actually ran the workload, by observing the executed syscalls, which read a file.</em></p><p>As I mentioned above, the observed behaviour may be unexpected and not ideal for some workloads, especially with lower CFS quotas. Even though, the app spent total 50ms on the CPU (25ms * 2 cores), it throttled for 75ms, per one CFS period. An HTTP server, that runs in a small container with 0.1 or 0.25 CPU, on a multi-core host system, will see this as the elevated tail latency in the handling of the requests.</p><p>Until Go becomes CFS aware one day (<a href=https://christopher-batey.medium.com/cpu-considerations-for-java-applications-running-in-docker-and-kubernetes-7925865235b7>like JVM</a>), the way to improve the situation is via fine-tuning <code>GOMAXPROCS</code>, overwriting its default value, to align with what amount of CPU is available to the container.</p><p>The <a href=https://pkg.go.dev/go.uber.org/automaxprocs><code>automaxprocs</code></a> package is a convenient way to do that:</p><pre tabindex=0><code>import (
	_ &#34;go.uber.org/automaxprocs&#34;
)
</code></pre><p>Let’s run the updated version of the app in a container, still restricting it with only 0.5 CPU:</p><pre tabindex=0><code>% docker container run --cpus 0.5 --rm -ti test-go-cpu-throttle
2023/01/11 19:05:07 maxprocs: Updating GOMAXPROCS=1: using minimum allowed GOMAXPROCS
Started
</code></pre><p>Observe that automaxprocs updated the GOMAXPROCS to <code>1</code> (the allowed minimum), restricting the application with only one CPU core.</p><p>The runtime trace now shows that the goroutines run on the single available proc, firing the <code>Read</code> syscalls for 50ms, and then do no work for the 50ms, just like we may expect for this quota:</p><figure><img src=/images/2023/trace_2.jpg width=1100></figure><p>For such a naive test application, the difference in the behaviour may not play a big role (if any at all). But, generally, such change makes the application’s performance more predictable, when we deploy Go applications in a container runtime, e.g. with Kubernetes, ECS, AWS Lambda, etc.</p><p><em>Share your thoughts about this note on <a href=https://twitter.com/tvii/status/1613540849693982722>Twitter</a>, or let&rsquo;s discuss it on <a href=https://www.reddit.com/r/golang/comments/109yw6j/go_runtime_vs_cfs_quota/>Reddit</a> and <a href="https://news.ycombinator.com/item?id=34352710">Hacker News</a>.</em></p><footer class=meta><time datetime=2023-01-12T12:00:00Z>January 12, 2023</time><a class=tag href=/notes/go/>Go</a><a class=tag href=/notes/kubernetes/>kubernetes</a><a class=tag href=/notes/linux/>linux</a></footer><section class="meta meta-topics-list"><header class=meta-topics-list-title><h3>All topics</h3></header><a class=tag href=https://vladimir.varank.in/notes/apple/>apple</a><a class=tag href=https://vladimir.varank.in/notes/arduino/>arduino</a><a class=tag href=https://vladimir.varank.in/notes/arm64/>arm64</a><a class=tag href=https://vladimir.varank.in/notes/askme/>askme</a><a class=tag href=https://vladimir.varank.in/notes/aws/>aws</a><a class=tag href=https://vladimir.varank.in/notes/berlin/>berlin</a><a class=tag href=https://vladimir.varank.in/notes/bookmarks/>bookmarks</a><a class=tag href=https://vladimir.varank.in/notes/buildkit/>buildkit</a><a class=tag href=https://vladimir.varank.in/notes/cgo/>cgo</a><a class=tag href=https://vladimir.varank.in/notes/coffee/>coffee</a><a class=tag href=https://vladimir.varank.in/notes/continuous-profiling/>continuous profiling</a><a class=tag href=https://vladimir.varank.in/notes/covid-19/>COVID-19</a><a class=tag href=https://vladimir.varank.in/notes/design/>design</a><a class=tag href=https://vladimir.varank.in/notes/docker/>docker</a><a class=tag href=https://vladimir.varank.in/notes/dynamodb/>dynamodb</a><a class=tag href=https://vladimir.varank.in/notes/e-paper/>e-paper</a><a class=tag href=https://vladimir.varank.in/notes/english/>english</a><a class=tag href=https://vladimir.varank.in/notes/enum/>enum</a><a class=tag href=https://vladimir.varank.in/notes/esp8266/>esp8266</a><a class=tag href=https://vladimir.varank.in/notes/firefox/>firefox</a><a class=tag href=https://vladimir.varank.in/notes/github-actions/>github actions</a><a class=tag href=https://vladimir.varank.in/notes/go/>Go</a><a class=tag href=https://vladimir.varank.in/notes/google/>google</a><a class=tag href=https://vladimir.varank.in/notes/graphql/>graphql</a><a class=tag href=https://vladimir.varank.in/notes/homelab/>homelab</a><a class=tag href=https://vladimir.varank.in/notes/ipv6/>IPv6</a><a class=tag href=https://vladimir.varank.in/notes/k3s/>k3s</a><a class=tag href=https://vladimir.varank.in/notes/kubernetes/>kubernetes</a><a class=tag href=https://vladimir.varank.in/notes/linux/>linux</a><a class=tag href=https://vladimir.varank.in/notes/macos/>macos</a><a class=tag href=https://vladimir.varank.in/notes/material-design/>material design</a><a class=tag href=https://vladimir.varank.in/notes/mdns/>mDNS</a><a class=tag href=https://vladimir.varank.in/notes/music/>music</a><a class=tag href=https://vladimir.varank.in/notes/ndppd/>ndppd</a><a class=tag href=https://vladimir.varank.in/notes/neondatabase/>neondatabase</a><a class=tag href=https://vladimir.varank.in/notes/objective-c/>objective-c</a><a class=tag href=https://vladimir.varank.in/notes/passkeys/>passkeys</a><a class=tag href=https://vladimir.varank.in/notes/postgresql/>postgresql</a><a class=tag href=https://vladimir.varank.in/notes/pprof/>pprof</a><a class=tag href=https://vladimir.varank.in/notes/profefe/>profefe</a><a class=tag href=https://vladimir.varank.in/notes/random/>random</a><a class=tag href=https://vladimir.varank.in/notes/raspberry-pi/>raspberry pi</a><a class=tag href=https://vladimir.varank.in/notes/rust/>rust</a><a class=tag href=https://vladimir.varank.in/notes/travis-ci/>travis ci</a><a class=tag href=https://vladimir.varank.in/notes/vs-code/>vs code</a><a class=tag href=https://vladimir.varank.in/notes/waveshare/>waveshare</a><a class=tag href=https://vladimir.varank.in/notes/%C2%B5-benchmarks/>µ-benchmarks</a></section></main><footer class=site-footer>#НетВойне<br><a href=mailto:vladimir@varank.in>vladimir@varank.in</a></footer><img src=https://c.varank.in/hello/*https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/ style=position:absolute;left:-9999px decoding=async alt></body></html>