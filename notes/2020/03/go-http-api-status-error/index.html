<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Handle HTTP API errors with StatusError - Vladimir Varankin</title><meta property="og:title" content="Handle HTTP API errors with StatusError"><meta property="og:description" content="Years ago, when I was sketching up the first prototype of [profefe][] I came up with a tiny pattern, that I keep using everytime I build an HTTP API.
When we build an HTTP API we tend to think about request&rsquo;s happy path only. For example,
In Go, building an HTTP part for a RESTful API isn&rsquo;t hard. You implement an http.Handler, that wraps API&rsquo;s buiseness logic"><meta property="og:type" content="article"><meta property="og:url" content="https://vladimir.varank.in/notes/2020/03/go-http-api-status-error/"><meta property="article:published_time" content="2020-03-03T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-03T00:00:00+00:00"><style>:root{--background-color: #fff;--text-color: #111;--header-color: #111;--link-color: rgb(0, 16, 161);--link-underline-color: rgba(0, 16, 161, 0.3);--link-hover-color: rgb(190, 0, 0);--link-hover-underline-color: rgba(190, 0, 0, 0.3)}@media(prefers-color-scheme:dark){:root.theme-dark{--background-color: #181818;--text-color: #cfcfcf;--header-color: #fefefe;--link-color: rgb(85, 172, 255);--link-underline-color: rgb(85, 172, 255, 0.8);--link-hover-color: rgb(231, 66, 66);--link-hover-underline-color: rgb(231, 66, 66, 0.8)}}body{background:var(--background-color);color:var(--text-color);font-family:Charter,Georgia,serif;font-size:16px;line-height:1.45;margin:8px 12px}h1,h2,h3,h4{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color)}a:hover,a:active{color:#be0000;color:var(--link-hover-color);text-decoration-color:var(--link-hover-underline-color)}ul{list-style:circle;max-width:840px}pre{line-height:1.3}code{font-family:Menlo,Consolas,monospace;font-size:14px}pre code{font-size:13px}hr{border:none;border-bottom:1px solid;width:90%}.main-nav{letter-spacing:.3em;padding-bottom:16px}.main-nav a,.main-nav span{letter-spacing:0}.main-content{max-width:900px}.main-footer{margin:50px 0 0}.article{margin:0 0 50px}.article-meta{font-size:14px;line-height:1}.tag{margin:0 0 0 .7em}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes>Notes</a>
<a href=/publications>Publications</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=main-head><h1>Handle HTTP API errors with StatusError</h1></header><p>Years ago, when I was sketching up the first prototype of [profefe][] I came up with a tiny pattern, that I keep using everytime I build an HTTP API.</p><p>When we build an HTTP API we tend to think about request&rsquo;s happy path only. For example,</p><p>In Go, building an HTTP part for a <em>RESTful</em> API isn&rsquo;t hard. You implement an <code>http.Handler</code>, that wraps API&rsquo;s buiseness logic</p><footer class=article-meta><time datetime=2020-03-03T12:00:00Z>March 3, 2020</time><span class=tag>go</span><span class=tag>error</span></footer></main><footer class=main-footer>Â© 2020 VLDMR</footer></body></html>