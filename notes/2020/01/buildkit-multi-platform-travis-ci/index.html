<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Building Multi-Platform Docker Images with Travis CI and BuildKit - Vladimir Varankin</title><link rel=canonical href=https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/><meta property="og:title" content="Building Multi-Platform Docker Images with Travis CI and BuildKit"><meta property="og:description" content="Docker has added the support for building multi-platform images in 19.x. However, the topic of building multi-platform Docker images yet feels underrepresented."><meta property="og:type" content="article"><meta property="og:url" content="https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/"><meta property="article:published_time" content="2020-01-27T00:00:00+00:00"><meta property="article:modified_time" content="2020-01-27T00:00:00+00:00"><style>:root{--background-color: #fff;--text-color: #131313;--header-color: #111;--link-color: rgb(0, 16, 161);--link-underline-color: rgba(0, 16, 161, 0.3);--link-active-color: rgb(231, 19, 19);--link-active-underline-color: rgba(231, 19, 19, 0.7)}html{font-size:16px;height:100%;margin:0;padding:0}body{background:var(--background-color);color:var(--text-color);display:grid;grid-template-rows:auto 1fr auto;font-family:Charter,Georgia,serif;font-size:1.1rem;line-height:1.4;margin:5px 1%;min-height:calc(100vh - 10px)}h1,h2,h3,h4,h5,h6{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1;margin:1.5em 0 .7em}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color)}a:hover,a:active{color:#be0000;color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}ul,ol{box-sizing:border-box;max-width:760px;padding:0}ol{padding-left:1.2em}ul>li{list-style:none;margin:.5em 0}pre{line-height:1.4;margin:1em 1.5em}code{font-family:Menlo,Consolas,monospace;font-size:15px}pre code{font-size:14px}hr{border:none;border-bottom:1px solid;width:90%}.main-nav{display:flex;letter-spacing:.3em;padding-bottom:16px}.main-nav a,.main-nav span{margin-right:.6em;letter-spacing:0}.main-nav-item-active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.main-content{max-width:940px}.main-footer{font-size:14px;margin:50px 0 0}.article{margin:0 0 50px}.article:last-child{margin-bottom:0}.article-head{font-size:28px}.article-head h1,.article-head h2{font-size:1em;margin-top:1em}.article-head h2{margin-bottom:0}.article-meta{font-size:14px;line-height:1;padding:5px 0 0}.tag{margin:0 0 0 7px}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes/ class=main-nav-item-active>Notes</a>
<a href=/publications/>Publications</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=article-head><h1>Building Multi-Platform Docker Images with Travis CI and BuildKit</h1></header><p><em>This is a lengthy note. If you don&rsquo;t quite feel reading and only need the working example, go directly to <a href=https://github.com/profefe/profefe/blob/09ff03be6561a7ef88fba7b96d923abd6a413931/.travis.yml>the Travis CI build file</a>.</em></p><p>The more I delve into the world of Raspberry Pi, the more I notice that &ldquo;regular and boring&rdquo; things on ARM are harder than I expected.</p><p>People build and distribute software exclusively for amd64. You read another &ldquo;<em>Kubernetes something</em>&rdquo; tutorial, that went viral on Twitter, and is fancy to try it out. Still, all helm charts, or whatever the author prefered, use Docker images built exclusively for amd64.</p><p>Docker toolchain has added the support for building multi-platform images in 19.x. However, it&rsquo;s available only under the &ldquo;experimental&rdquo; mode. The topic of building multi-platform Docker images yet feels underrepresented.</p><h2 id=but-first-what-are-multi-platform-docker-images>But first, what are multi-platform Docker images?</h2><p>When a client, e.g. Docker client, tries to pull an image, it must negotiate the details about what exactly to pull with the registry. The registry provides a manifest that describes the digest of the requested image, the volumes the image consists of, the platform this image can run on, etc. Optionally, the registry can provide a manifests list, which, as the name suggests, is a list of several manifests bundled into one. With the manifests list in hands, the client can figure out the particular digest of the image it needs to pull.</p><p>So multi-platform Docker images are just several images, whose manifests are bundled into the manifests list.</p><p>Imagine we want to pull the image <a href=https://hub.docker.com/_/golang><code>golang:1.13.6-alpine3.10</code></a>. Docker client will get the manifests list from Dockerhub. This list includes digests of several images, each built for the particular platform. If we&rsquo;re on Raspberry Pi, running the current Raspbian Linux, which is <code>arm/v7</code>, the client will pick the corresponding image&rsquo;s digest. Alternatively, we could choose to pull the image <a href=https://hub.docker.com/r/arm32v7/golang/><code>arm32v7/golang:1.13.6-alpine3.10</code></a> instead, and we ended up with the same image with the <a href=https://hub.docker.com/layers/arm32v7/golang/alpine3.10/images/sha256-d72fa60fb5b9ffc12db9c87340bc9d9f55852570f1efc7d7656f081749a7f0aa>digest <code>d72fa60fb5b9</code></a>. Of course, to use a single universal image name, i.e. <code>golang</code>, on every platform is way more convenient.</p><p>You can read more about manifests <a href=https://docs.docker.com/registry/spec/manifest-v2-2/>in Docker registry documentation</a>.</p><h2 id=does-it-mean-i-need-to-build-different-docker-images-for-each-platform-i-want-to-support>Does it mean I need to build different Docker images, for each platform I want to support?</h2><p>Well, yes. This is how, official images are built.</p><p>For every platform, the image is built and pushed to the registry under the name <code>&lt;platform>/&lt;image>:&lt;tag></code>, e.g. <a href=https://hub.docker.com/r/amd64/golang/><code>amd64/golang:1-alpine</code></a>. And next, a manifests list, that combines all those platform-specific images, is built and pushed with the simple name <code>&lt;image>:&lt;tag></code>.</p><p><a href=https://github.com/moby/buildkit>Docker&rsquo;s BuildKit</a> provides a toolkit that, among other nice things, allows building multi-platform images on a single host. BuildKit is used inside <a href=https://github.com/docker/buildx>Docker' buildx project</a>, that is part of the recent Docker version.</p><p>One can use buildx, but, for this post, I wanted to try out, what would it look like to use BuildKit directly. For <a href=https://github.com/profefe/profefe>profefe</a>, the system for continuous profiling of Go services, I set up <a href=https://travis-ci.com/>Travis CI</a>, that builds a multi-platform Docker image and pushes them to Dockerhub.</p><p>profefe is written in Go. That simplifies things, because, thanks to Go compiler, I don&rsquo;t have to think about how to compile code for different platforms. <a href=https://github.com/profefe/profefe/blob/09ff03be6561a7ef88fba7b96d923abd6a413931/contrib/docker/Dockerfile>The same Dockerfile</a> will work fine on every platform.</p><p>Here&rsquo;s how &ldquo;deploy&rdquo; stage of the build job looks like (<a href=https://github.com/profefe/profefe/blob/09ff03be6561a7ef88fba7b96d923abd6a413931/.travis.yml>see <code>travis.yml</code> on profefe&rsquo;s GitHub</a>).</p><pre><code>dist: bionic

language: go
go:
  - 1.x

jobs:
  include:
    - stage: deploy docker
      services: docker
      env:
        - PLATFORMS=&quot;linux/amd64,linux/arm64,linux/arm/v7&quot;
      install:
        - docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes
        - docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest
        - sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/
        - export BUILDKIT_HOST=&quot;docker-container://buildkitd&quot;
      script: skip
      deploy:
        - provider: script
          script: |
            buildctl build \
              --progress=plain \
              --frontend=dockerfile.v0 \
              --local context=. --local dockerfile=. \
              --opt filename=contrib/docker/Dockerfile \
              --opt platform=$PLATFORMS \
              --opt build-arg:VERSION=\&quot;master\&quot; \
              --opt build-arg:GITSHA=\&quot;$TRAVIS_COMMIT\&quot; \
              --output type=image,\&quot;name=profefe/profefe:git-master\&quot;,push=true
          on:
            repo: profefe/profefe
            branch: master
      before_deploy:
        - echo &quot;$DOCKER_PASSWORD&quot; | docker login --username &quot;$DOCKER_USERNAME&quot; --password-stdin
      after_failure:
        - buildctl debug workers ls
        - docker container logs buildkitd
</code></pre><p>It&rsquo;s a lot happening here, but I&rsquo;ll describe the most critical parts.</p><p>Let&rsquo;s start with <code>dist: bionic</code>.</p><p>We run the builds under Ubuntu 18.04 (Bionic Beaver). To be able to build multi-platform images on a single amd64 host, BuildKit uses QEMU to emulate other platforms. That requires Linux kernel 4.8, so even Ubuntu 16.04 (Xenial Xerus) should work.</p><p>The top-level details on how the emulation works are very well described in <a href=https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html>https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html</a></p><p>In short, we tell the component of the kernel (<code>binfmt_misc</code>) to use QEMU when the system executes a binaries built for a different platform. The following call in the &ldquo;install&rdquo; step is what&rsquo;s doing that:</p><pre><code>- docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes
</code></pre><p>Under the hood, the container runs a <a href=https://raw.githubusercontent.com/qemu/qemu/master/scripts/qemu-binfmt-conf.sh>shell script from QEMU project</a>, that registers the emulator as an executor of binaries from the external platforms.</p><blockquote><p>If you think, that running a docker container to do the manipulations with the host&rsquo;s OS looks weird, well&mldr; I can&rsquo;t agree more. Probably, a better approach would be to install <a href=https://packages.ubuntu.com/bionic/qemu-user-static>qemu-user-static</a>, which would do the proper setup. Unfortunately, the current package&rsquo;s version for Ubuntu Bionic doesn&rsquo;t do the registration as we need it. I.e. its post-install doesn&rsquo;t add the <code>"F"</code> flag (&ldquo;fix binaries&rdquo;), which is crucial for our goal. Let&rsquo;s just agree,that docker-run will do ok for the demonstrational purpose.</p></blockquote><pre><code>- docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest
- sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/
- export BUILDKIT_HOST=&quot;docker-container://buildkitd&quot;
</code></pre><p>This is another &ldquo;docker-run&rsquo;ism&rdquo;. We start BuildKit&rsquo;s <code>buildkitd</code> daemon inside the container, attaching it to the Docker daemon that runs on the host (&ldquo;privileged&rdquo; mode). Next, we copy <code>buildctl</code> binary from the container to the host system and set <code>BUILDKIT_HOST</code> environment variable, so <code>buildctl</code> knew where its daemon runs.</p><blockquote><p>Alternatively, we could install BuildKit from GitHub and run the daemon directly on the build host. YOLO.</p></blockquote><pre><code>before_deploy:
  - echo &quot;$DOCKER_PASSWORD&quot; | docker login --username &quot;$DOCKER_USERNAME&quot; --password-stdin
</code></pre><p>To be able to push the images to the registry, we need to log in providing Docker credentials to host&rsquo;s Docker daemon. The credentials are set as Travis CI&rsquo;s encrypted environment variables ([refer to Travis CI docs])](<a href=https://docs.travis-ci.com/user/environment-variables/))>https://docs.travis-ci.com/user/environment-variables/))</a>.</p><pre><code>buildctl build \
  --progress=plain \
  --frontend=dockerfile.v0 \
  --local context=. --local dockerfile=. \
  --opt filename=contrib/docker/Dockerfile \
  --opt platform=$PLATFORMS \
  --opt build-arg:VERSION=\&quot;master\&quot; \
  --opt build-arg:GITSHA=\&quot;$TRAVIS_COMMIT\&quot; \
  --output type=image,\&quot;name=profefe/profefe:git-master\&quot;,push=true
</code></pre><p>This is the <em>black box</em> where everything happens. Magically!</p><p>We run <code>buildctl</code> stating that it must use the specified Dockerfile; it must build the images for defined platforms (I specified <code>linux/amd64,linux/arm64,linux/arm/v7</code>), create a manifests list tagged as the desired image (<code>profefe/profefe:&lt;version></code>), and push all the images to the registry.</p><p><code>buildctl debug workers ls</code> shows what platforms does BuildKit on this host support. I listed only those I&rsquo;m currently intrested with.</p><p>And that&rsquo;s all. This setup automatically builds and pushes multi-platform Docker images for profefe (<a href=https://hub.docker.com/p/profefe/profefe>https://hub.docker.com/p/profefe/profefe</a>) on a commit to project&rsquo;s &ldquo;master&rdquo; branch on GitHub.</p><hr><p>As I hope you&rsquo;ve seen, support for multi-platform is getting easier and things that were hard a year ago are only mildly annoying now :)</p><p>If you have any comments or suggestions, reach out to me on <a href=https://twitter.com/tvii/status/1221858810006065154>Twitter</a> or discuss this note on <a href=https://www.reddit.com/r/docker/comments/eutrkg/building_multiplatform_docker_images_with_travis/>r/docker Reddit</a>.</p><p>Some more reading on the topic:</p><ul><li><a href=https://github.com/moby/buildkit>Documentation for BuildKit project</a></li><li><a href=https://github.com/docker/buildx#building-multi-platform-images>Building multi-platform images with docker and buildx</a></li><li><a href=https://www.docker.com/blog/docker-official-images-now-multi-platform/>Docker Official Images are now Multi-platform, Docker official announcement</a></li></ul><footer class=article-meta><time datetime=2020-01-27T12:00:00Z>January 27, 2020</time><span class=tag>docker</span><span class=tag>buildkit</span><span class=tag>travis ci</span><span class=tag>raspberry pi</span></footer></main><footer class=main-footer>© 2020 #SocialDistancing</footer><div><img src=https://raw.githubusercontent.com/narqo/narqo.github.io/master/1.gif style=position:absolute;left:-9999px alt></div></body></html>