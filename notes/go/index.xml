<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/go/</link><description>Recent content in Go on Vladimir Varankin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 29 Jan 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Client-side pagination in Go (range-over function edition)</title><link>https://vladimir.varank.in/notes/2024/01/client-side-pagination-in-go-range-over-function-edition/</link><pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2024/01/client-side-pagination-in-go-range-over-function-edition/</guid><description>&lt;p>In light of Go 1.22&amp;rsquo;s experiment, that allows iterating over a function, I wanted to revisit my note from 2022 on &lt;a href="https://vladimir.varank.in/notes/2022/05/a-real-life-use-case-for-generics-in-go-api-for-client-side-pagination/">client-side pagination, using a generic iterator&lt;/a>, and get an idea on how the range-over function might help with the task. I will not delve into the details of the changes that Go brings. Refer to the &amp;ldquo;&lt;a href="https://go.dev/wiki/RangefuncExperiment">Rangefunc Experiment&lt;/a>&amp;rdquo; on the Go wiki for more details. One only thing to mention, is that the executable must be built with the &lt;code>GOEXPERIMENT=rangefunc&lt;/code> environment variable, to enable the experiment.&lt;/p></description></item><item><title>Compile-time safety for enumerations in Go</title><link>https://vladimir.varank.in/notes/2023/09/compile-time-safety-for-enumerations-in-go/</link><pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2023/09/compile-time-safety-for-enumerations-in-go/</guid><description>Last month, a colleague of mine asked how to reason about enumerated values (&amp;ldquo;enums&amp;rdquo;) in Go. They wanted to benefit from Go&amp;rsquo;s type-safety and to prevent users from misusing the package.
For an imaginary example, that enumerates possible colours, the snippet below shows how we typically implement this:
type Color string const ( Red Color = &amp;#34;red&amp;#34; Green Color = &amp;#34;green&amp;#34; Blue Color = &amp;#34;blue&amp;#34; ) But, just like Bill Kennedy illustrated it in the blog post on a similar topic, such implementation allows a user to pass any &amp;ldquo;untyped constant string&amp;rdquo; in places where the Color type is expected. Also, a user can declare their own value of a type Color, going beyond what was defined by the initial enumeration set.
package main func main() { PrintColor(color.Red) PrintColor(&amp;#34;RAINBOW&amp;#34;) var rainbow color.Color = &amp;#34;üåà&amp;#34; PrintColor(rainbow) } func PrintColor(c color.Color) { fmt.Printf(&amp;#34;%v\n&amp;#34;, c) } // Outputs: red RAINBOW üåà Note how in the snippet above, the user both called PrintColor(‚ÄúRAINBOW‚Äù) and defined their own variable of type color.Color, which holds a random string.
Update: a number of people pointed at my choice of words in the paragraph below, where I introduce a way to solve the problems. Indeed, &amp;ldquo;elegant&amp;rdquo; isn&amp;rsquo;t the most accurate one to describe this solution :) Also, refer to #19412 for the discussion about adding sum types to Go.
Go&amp;rsquo;s type system allows preventing both issues in a rather elegant way. Let&amp;rsquo;s declare the Color interface, with an unexported method, while implementing this interface in an unexported type color:
package color type Color interface { xxxProtected() } type color string func (c color) xxxProtected() {} const ( Red color = &amp;#34;red&amp;#34; Green color = &amp;#34;green&amp;#34; Blue color = &amp;#34;blue&amp;#34; ) Because no types outside of our package color can implement the unexported method color.Color.xxxProtected(), we limit the possible implementations of the Color interface to only values, defined in the package color.
package main func main() { PrintColor(color.Red) //PrintColor(&amp;#34;RAINBOW&amp;#34;) // cannot use (constant of type string) as color.Color } func PrintColor(c color.Color) { fmt.Printf(&amp;#34;%v\n&amp;#34;, c) } If a user tries to pass an untyped constant string or declare their own variant of the colour, the code won&amp;rsquo;t compile, resulting with an error:
package main type mycolor string func (c mycolor) xxxProtected() {} func main() { black := mycolor(&amp;#34;BLACK&amp;#34;) PrintColor(black) } OUTPUTS: ./prog.go:9:13: cannot use black (variable of type mycolor) as color.Color value in argument to PrintColor: mycolor does not implement color.Color (missing method xxxProtected) Have you stumbled upon a scenario, where such strict compile-time checks for enumerated values was needed? Share your thoughts with me on Hacker News, Twitter or Bluesky.</description></item><item><title>Env variables, you will (likely) find set in my Kubernetes deployments</title><link>https://vladimir.varank.in/notes/2023/05/env-variables-you-will-likely-find-set-in-my-kubernetes-deployments/</link><pubDate>Mon, 01 May 2023 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2023/05/env-variables-you-will-likely-find-set-in-my-kubernetes-deployments/</guid><description>&lt;p>Kubernetes allows us to pass the values declared in a Pod&amp;rsquo;s manifest, to its containers via environment variables (&lt;a href="https://kubernetes.io/docs/tasks/inject-data-application/environment-variable-expose-pod-information/">docs&lt;/a>). A typical situation, where I find this handy is when I run a Go application in a Pod.&lt;/p>
&lt;p>As discussed in the previous note, out of the box, &lt;a href="https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/">Go runtime isn&amp;rsquo;t aware if it runs inside a container&lt;/a>. This can lead to confusing situations, when the runtime adjusts its behaviour, after observing the resources (CPU and memory) available on the cluster&amp;rsquo;s node, instead of the resources, a developer or an operator restricted the deployment with.&lt;/p></description></item><item><title>Go runtime vs CFS quota</title><link>https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/</guid><description>&lt;p>As of today, the Go runtime isn&amp;rsquo;t aware if it runs inside a container under the resource constraints (CPU or memory). The runtime sees the resources available for the container&amp;rsquo;s underlying host OS, e.g. the VM where the container runs, and tries to optimize its behaviour base on what it sees. For container runtimes on Linux, which implements the CPU restrictions via CFS (&amp;ldquo;Completely Fair Scheduler&amp;rdquo;), a mismatch in what the application thinks is has, and what the OS allows to use, can lead to the poor performance of the application after the unexpected throttling.&lt;/p>
&lt;p>For example, a Go application, that runs in a container, constrained with 0.5 CPU, running on a host with 2 CPU, will observe 2 available CPU cores. That is the application&amp;rsquo;s calls to &lt;a href="https://pkg.go.dev/runtime#NumCPU">&lt;code>runtime.NumCPU()&lt;/code>&lt;/a> and &lt;a href="https://pkg.go.dev/runtime#GOMAXPROCS">&lt;code>runtime.GOMAXPROCS()&lt;/code>&lt;/a> will get us &amp;ldquo;2&amp;rdquo;. Because the Go runtime is optimized for the maximum utilization of the available compute under the concurrent workload, the goroutines it spawns are distributed to the internal thread pool, created with the assumption of two available CPU cores. This causes the application to throttle after the sum of the time it spend on the CPU cores per CFS period become equals to the quota of the container. With &lt;a href="https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html#management">the default CFS period&lt;/a> 100ms, the CFS quota of this container 0.5 CPU, and two threads running on different CPU cores, the application is throttled after 25ms every 100ms.&lt;/p></description></item><item><title>Bookmarks (issue 10)</title><link>https://vladimir.varank.in/notes/2022/12/bookmarks-10/</link><pubDate>Sat, 31 Dec 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/12/bookmarks-10/</guid><description>The 22 BEST Basslines of 2022 (Patrick Hunter).
Building a custom code search index in Go for searchcodecom (Ben Boyter).
Kubernetes resources under the hood. This year was rich for deep tech articles and talks, that explain how CPU requests and limits work in Kubernetes. This three-part series is no exception.
John Carmack on resigning from Meta. A post that spawned many intresting opinions on the internet: &amp;ldquo;You can&amp;rsquo;t have top people in X (performance, security, whatever) work for you and only half-care about X at the same time. They will move&amp;rdquo;.</description></item><item><title>How "go test" runs tests</title><link>https://vladimir.varank.in/notes/2022/12/how-go-test-runs-tests/</link><pubDate>Thu, 15 Dec 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/12/how-go-test-runs-tests/</guid><description>When I run go test ./foo, Go toolchain performs several tricks under the hood.
First ‚Äî skipping the intermediate preparation steps, like parsing the command line flags and checking for cached results ‚Äî the toolchain generates a package main, which will run all TestXxx functions for a package under the test. Then it compiles a testing-binary, that includes the generated code, and the code of the package and its _test.go files.
The steps above are somewhere equivalent to running the following command:
&amp;gt; go test -c -o foo.test ./foo # The resulting &amp;#34;foo.test&amp;#34; is indeed an executable &amp;gt; file foo.test foo.test: Mach-O 64-bit executable x86_64 This binary includes a generated function &amp;ldquo;main&amp;rdquo;, that, eventually, calls the packages TestMain(m *testing.M) (if one exists), and executes all the TestXxx(t *testing.T) functions, which the toolchain found during the code-generation.
For the details of how the generated &amp;ldquo;main&amp;rdquo; looks like, refer to the source code of the internal package &amp;ldquo;load&amp;rdquo;.
Next, the toolchain executes the built binary, setting the current working directory to the path of the original package foo, which is equivalent to running the following:
&amp;gt; cd ./foo &amp;gt; ./../foo.test The important (and sometimes not obvious) part is that Go toolchain builds a dedicated binary for every package, under the testing scope. That is, in the example above, the testing binary contains only the code of the package &amp;ldquo;foo&amp;rdquo;, its dependencies, and the code in its _test.go files. If we ran the tests for several packages ‚Äî go test ./pkg/... ‚Äî the toolchain will generate, built and execute individual binaries for every package below pkg/. This makes the testing of each package fully-isolated.
There are lots of other things happening underneath, including code coverage, benchmarking, etc. Have a look through the documentation under go help test and go help testflag, for some more details.</description></item><item><title>Bookmarks (issue 9)</title><link>https://vladimir.varank.in/notes/2022/11/bookmarks-9/</link><pubDate>Wed, 30 Nov 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/11/bookmarks-9/</guid><description>Kubernetes removals, deprecations, and major changes in 1.26.
Performance evaluation of autoscaling strategies in Kubernetes (Kewyn Akshlley). tl;dr; After comparing the performance of horizontal and vertical autoscaling using synthetic load, the horizontal autoscaling seems more efficient, reacts faster to the load variation, and results in a lower impact on the application&amp;rsquo;s response time.
How Pinterest delivers software at scale (Go Time, podcast). A very refreshing discussion about real-world technical challenges large organizations face.
Adam Dymitruk on Event Modeling (Software Engineering Radio, podcast). Event Modeling: what is it?</description></item><item><title>Bookmarks (issue 6)</title><link>https://vladimir.varank.in/notes/2022/08/bookmarks-6/</link><pubDate>Wed, 31 Aug 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/08/bookmarks-6/</guid><description>Kubernetes antipatterns: CPU Limits. Always define CPU requests; never define CPU limits.
Explaining the unexplainable: buffers in PostgreSQL. Shared buffers are those, which&amp;rsquo;re&amp;rsquo; &amp;ldquo;shared&amp;rdquo; between several DB sessions, i.e. data pages, indices, etc; local buffers, are &amp;ldquo;local&amp;rdquo; to a session, i.e. for temporal tables; temp buffers are for intermediate objects, i.e. when the DBMS does hashing and sorting.
Rust Iterator pattern with iter(), into_iter() and iter_mut() methods.
Standard iterator interface in Go (Ian Lance Taylor via GitHub Discussions).</description></item><item><title>Bookmarks (issue 4)</title><link>https://vladimir.varank.in/notes/2022/06/bookmarks-4/</link><pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/06/bookmarks-4/</guid><description>Go 1.19beta1. As usual, lots of good improvements in the language&amp;rsquo;s runtime and the compiler, with one particularly interesting addition being the new &amp;ldquo;knob&amp;rdquo; runtime/debug.SetMemoryLimit.
How to use gender-neutral language at work and in life (Grammarly). &amp;ldquo;Luckily, the English language is relatively gender-neutral in many respects&amp;rdquo; [at least, when compared to Russian and German languages].
Meet passkeys (Apple) and Everything you want to know about WebAuthn (OktaDev). As you can guess, I&amp;rsquo;m very excited with Apple stepping onto the path to a passwordless future, while betting on WebAuthn standard.
Replace CAPTCHAs with Private Access Tokens (Apple), Private Access Tokens: stepping into the privacy-respecting, CAPTCHA-less future we were promised (Fastly), Private Access Tokens: eliminating CAPTCHAs on iPhones and Macs with open standards (Cloudflare).</description></item><item><title>A real life use-case for generics in Go: API for client-side pagination</title><link>https://vladimir.varank.in/notes/2022/05/a-real-life-use-case-for-generics-in-go-api-for-client-side-pagination/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/05/a-real-life-use-case-for-generics-in-go-api-for-client-side-pagination/</guid><description>&lt;p>Let&amp;rsquo;s say we have a RESTful API for a general ledger, with the endpoints, that return a paginated collection of resources:&lt;/p>
&lt;ol>
&lt;li>&lt;code>GET /accounts&lt;/code>, retrieves a list of accounts, filtered and sorted by some query parameters;&lt;/li>
&lt;li>&lt;code>GET /accounts/:uuid/transactions&lt;/code>, retrieves a list of transactions for account;&lt;/li>
&lt;li>&lt;code>GET /postings&lt;/code>, retrieves a list of &lt;a href="https://en.wikipedia.org/wiki/Double-entry_bookkeeping">postings&lt;/a> stored in the ledger.&lt;/li>
&lt;/ol></description></item><item><title>Bookmarks (issue 1)</title><link>https://vladimir.varank.in/notes/2022/03/bookmarks-1/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/03/bookmarks-1/</guid><description>Generics can make your Go code slower (PlanetScale):
boxing vs monomorphization vs partial monomorphization (&amp;ldquo;GCShape stenciling with Dictionaries&amp;rdquo;) interface inlining doesn&amp;rsquo;t work well with the 1.18&amp;rsquo;s compiler generics work well for byte sequences (string | []byte) in simple cases, generics can be useful for function callbacks. How Meta enables de-identified authentication at scale. The rational, the use-cases, and a high-level architecture of Meta&amp;rsquo;s Anonymous Credential Service (ACS).
Hidden dangers of duplicate key violations in PostgreSQL (AWS). INSERT ‚Ä¶ ON CONFLICT has additional benefits, if compared to relying on PostgreSQL&amp;rsquo;s &amp;ldquo;duplicate key violation&amp;rdquo; error:
no additional space needed for dead tuples less autovacuum required transaction IDs aren&amp;rsquo;t used for nothing, preventing (postponing) the potential trx-id wraparound. Diving into AWS IAM Roles for (Kubernetes) Service Accounts (IRSA).</description></item><item><title>Go talks I keep coming back to</title><link>https://vladimir.varank.in/notes/2022/02/go-talks-i-keep-coming-back-to/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/02/go-talks-i-keep-coming-back-to/</guid><description>I have a personal list of &amp;ldquo;top conference talks&amp;rdquo; that I keep referring back to, even after years of working with Go:
Go profiling from bottom up, Felix Geisend√∂rfer, GoLab 2021. Felix explains what&amp;rsquo;s under the hood of Go&amp;rsquo;s pprof. Evolving the Go Memory Manager&amp;rsquo;s RAM and CPU Efficiency, Michael Knyszek, GopherCon 2020 Death by 3,000 Timers: Streaming Video-on-Demand for Cable TV, Chris Hines, GopherCon 2019. Chris explains the mechanics behind the Go runtime scheduler, following the anomaly cases, they observed, when ran a Go application on a physical machine, with large number of CPU cores. Rethinking Classical Concurrency Patterns (Slides), Bryan C. Mills, GopherCon 2018. Brian demos the implementation of typical concurrency patterns, following the famous Go proverb: &amp;ldquo;Don&amp;rsquo;t communicate by sharing memory; share memory by communicating.&amp;rdquo; GoLab Keynote, Bill Kennedy, GoLab 2018. Bill demoes the ways to reason about the performance of a Go application, with the help of Go runtime tracer. The Scheduler Saga, Kavya Joshi, GopherCon 2018. Kavya shows what stands behind the magic of Go runtime. Restarting Go applications gracefully (in Russian), –°–µ—Ä–≥–µ–π –ö–∞–º–∞—Ä–¥–∏–Ω, GopherCon Russia 2018 Advanced Testing with Go, Mitchell Hashimoto, GopherCon 2017 Understanding Channels, Kavya Joshi, GopherCon 2017. Kavya explains how channels work under the hood. Keeping the list here, in public, should help my future self, in a situation where I&amp;rsquo;m stuck with a mind-blocker, and I need to quickly pull out a piece of community wisdom from the backyards of my memory. The list isn&amp;rsquo;t meant to be complete, and I expect to add more links here, moving forward.
Did I miss any? Share your suggestions with me on Twitter.</description></item><item><title>Error messages in Go</title><link>https://vladimir.varank.in/notes/2021/12/error-messages-in-go/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/12/error-messages-in-go/</guid><description>When Go code propagates an error, the following pattern is very popular:
fmt.Errorf(&amp;#34;failed to find a parking slot: %w&amp;#34;, err) // Or fmt.Errorf(&amp;#34;could not call mom: %w&amp;#34;, err) These &amp;ldquo;could not&amp;rdquo;, &amp;ldquo;failed to&amp;rdquo;, &amp;ldquo;unable to&amp;rdquo; make sense when my mind is in the local context of the function, method or package. But, in most of the cases I have to deal with, it makes the resulting log message overloaded with informational garbage:
unable to ask about the cat: failed to call mom: failed to do request: Get https://: context canceled While discussing this issue with a colleague, we came up with the following &amp;ldquo;better&amp;rdquo; strategy:
only the logger should express its attitude to the facts, using words &amp;ldquo;error&amp;rdquo;, &amp;ldquo;failed&amp;rdquo;, etc the business code must operate only with facts, e.g. &amp;ldquo;call mom&amp;rdquo;. err := CallMom(number) if err != nil { return fmt.Errorf(&amp;#34;call mom (tel %s): %w&amp;#34;, number, err) } This renders as following to the application logs:
error: ask about cat: call mom (tel 123): make request: Get https://: context canceled For a long stack of errors, this makes the full error message more dense, showing more useful information per line.</description></item><item><title>Little things of Go HTTP handlers</title><link>https://vladimir.varank.in/notes/2021/03/little-things-of-go-http-handlers/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/03/little-things-of-go-http-handlers/</guid><description>Every time I sketch an HTTP API in Go, I wrap the code of request handlers around these small but very convenient bits.
My handlers are methods or functions, that serve a request and, either write a (positive) response or return an error.
// HandlerFunc is an HTTP handler function, that handles an HTTP request. // It writes the response to http.ResponseWriter or returns an error. type HandlerFunc func(w http.ResponseWriter, r *http.Request) error // Handler is an adaptor for HandlerFunc, that converts the handler into http.Handler. // It makes sure all errors returned from h are handled in a consistent manner. func Handler(h HandlerFunc) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { err := h(w, r) if err != nil { handleError(w, r, err) } }) } An error returned from HandlerFunc can be an indicator of a failure in request processing, statusError, or a general &amp;ldquo;something didn&amp;rsquo;t work&amp;rdquo;-error. The later can contain the internal details, that the API must never expose to the user.
// StatusError wraps an error err and contains the suggestion regarding to // how the error should be communicated to the user. // // code must be a valid HTTP status code; text is the message to reply to user. func StatusError(code int, text string, err error) error { return &amp;amp;statusError{ Code: code, Text: text, Err: err, } } type statusError struct { Code int Text string Err error } func (s statusError) Error() string { return s.Text } func (s statusError) Unwrap() error { return s.Err } handleError is a helper function, which makes sure all errors returned from HandlerFunc are handled and replied to the user consistently. The internal details ‚Äî the cause of the error ‚Äî aren&amp;rsquo;t exposed to the user, but the helper can provide a unified logging and metrics, which would be convenient when debugging the error later:
var ErrNotFound = StatusError(http.StatusNotFound, &amp;#34;Nothing found&amp;#34;, nil) func handleError(w http.ResponseWriter, r *http.Request, err error) { var statusErr *statusError if !errors.As(err, &amp;amp;statusErr) { statusErr = &amp;amp;statusError{Code: http.StatusInternalServerError, Text: &amp;#34;Internal server error&amp;#34;, Err: err} } rid := RequestIDFromContext(r.Context()) resp := errResponse{ RequestID: rid, Error: statusErr.Text, } replyJSON(w, resp, statusErr.Code) // underlying error can be nil, as a special case, when the error is a client-side problem if err := errors.Unwrap(statusErr); err != nil { log.Errorw(&amp;#34;request failed&amp;#34;, &amp;#34;request-id&amp;#34;, rid, &amp;#34;uri&amp;#34;, r.RequestURI, &amp;#34;error&amp;#34;, err) } } replyJSON is a helper function, which writes a JSON string to http.ResponseWriter, setting the proper HTTP headers.
func replyJSON(w http.ResponseWriter, v interface{}, code int) { w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;) w.WriteHeader(code) err := json.NewEncoder(w).Encode(v) if err != nil { io.WriteString(w, `{&amp;#34;code&amp;#34;:500,&amp;#34;error&amp;#34;:`+strconv.Quote(err.Error())+`}`) } } How does it look in practice?
Below is an extract from a hypothetical API, with one single route /api/login, that takes an email, and replies with JSON, that contains this account&amp;rsquo;s ID.
func setupRoutes(mux *http.ServeMux) { authHandler := NewAuthHandler(¬∑¬∑¬∑) mux.Handle(&amp;#34;/api/login&amp;#34;, Handler(authHandler.HandleLogin)) } type AuthHandler { // internal dependencies } func (h *AuthHandler) HandleLogin(w http.ResponseWriter, r *http.Request) error { ctx := r.Context() req, err := DecodeLoginRequest(r) if err != nil { return fmt.Errorf(&amp;#34;decode login request: %w&amp;#34;, err) } if req.Email == &amp;#34;&amp;#34; { return StatusError(http.StatusBadRequest, &amp;#34;email is required&amp;#34;, nil) } accID, err := h.datastore.GetAccountByEmail(ctx, req.Email) if errors.Is(err, ErrNotExists) { return StatusError(http.StatusForbidden, &amp;#34;account does not exist&amp;#34;, err) } if err != nil { return fmt.Errorf(&amp;#34;get account for %q: %w&amp;#34;, req.Email, err) } resp := struct { ID string `json:&amp;#34;id&amp;#34;` }{ ID: accID, } // ReplyJSON is a wrapper around internal replyJSON, that always responses with http.StatusOK ReplyJSON(w, resp) return nil } Do you have your own little things, that help you to lay out the boilerplate? Discuss this note on Twitter or Reddit.</description></item><item><title>(You don't) Insert unicode NULL character as Postgres jsonb</title><link>https://vladimir.varank.in/notes/2021/01/you-dont-insert-unicode-null-character-as-postgres-jsonb/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/01/you-dont-insert-unicode-null-character-as-postgres-jsonb/</guid><description>With JSON data type it‚Äôs easy to treat Postgres as a document database, which doesn‚Äôt need strong schema. One can define a table, that has a field of a type jsonb and insert any valid JSON string (a ‚Äúdocument‚Äù).
I‚Äôve learned lately, that Postgres‚Äôs jsonb prohibits insertion of a valid JSON string if the string contains NULL (U+0000) character. Postgres‚Äôs own docs on JSON Types says:
RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by \uXXXX. In the input function for the json type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness. However, the input function for jsonb is stricter: it disallows Unicode escapes for non-ASCII characters (those above U+007F) unless the database encoding is UTF8. The jsonb type also rejects \u0000 (because that cannot be represented in PostgreSQL&amp;rsquo;s text type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct.
In my case, a Go backend inserts tracing logs to Postgres. A trace consists of multiple ‚Äúspans‚Äù, some of which can contain the reply from an external API. As we found out, sometimes, in the event of a failure, the API replies with an empty GIF &amp;lt;facepalm/&amp;gt;. Our backend converts the response to a string, marshals it to a JSON and later tries to insert the JSON into a Postgres table.
Consider the following Go code:
// data is an empty GIF var data = []byte{ 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x21, 0xf9, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02, 0x01, 0x44, 0x00, 0x3b, } func main() { v, _ := json.Marshal(struct { Resp interface{} `json:&amp;#34;resp,omitempty&amp;#34;` }{ Resp: string(data), }) fmt.Printf(&amp;#34;%s\n&amp;#34;, v) // Output (truncated for readability): // {&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\u0000\ufffd\¬∑¬∑¬∑\u0001D\u0000;&amp;#34;} } Above, json.Marshal produces a perfectly valid JSON. But if I try to insert it into a Postgres table as jsonb, the insert fails with ‚Äúunsupported Unicode escape sequence‚Äù:
= CREATE TABLE logs (data jsonb); = INSERT INTO logs VALUES (&amp;#39;{&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\u0000\ufffd\¬∑¬∑¬∑\u0001D\u0000;&amp;#34;}&amp;#39;); ERROR: unsupported Unicode escape sequence LINE 1: insert into logs values (&amp;#39;{&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\... ^ DETAIL: \u0000 cannot be converted to text. CONTEXT: JSON data, line 1: {&amp;#34;resp&amp;#34;:... Because in my code, there were only a couple of places where I didn&amp;rsquo;t control the actual data, that went into a span, the way I‚Äôve chosen to handle that was by introducing a wrapper type, that implements json.Marshaller. The wrapper checks the value is a valid UTF-8 sequence and doesn‚Äôt contain NULL character before it marshals the value into a JSON string. If the value is not a valid UTF-8, the marshaller sees it as a binary data and base64-encodes it.
// RawText handles invalid UTF-8 and NULL-bytes, encoding them as base64-string. // Because we have to make sure the resulting JSON will be compatible with Postgres&amp;#39;s jsonb, // we must use RawText when we don&amp;#39;t control the data, e.g. when log the error from an external API. // Refer to https://www.postgresql.org/docs/10/datatype-json.html type RawText []byte func (v RawText) MarshalEasyJSON(w *Writer) { if utf8.Valid(v) &amp;amp;&amp;amp; !bytes.ContainsRune(v, &amp;#39;\u0000&amp;#39;) { // &amp;#34;valid&amp;#34; text is marshalled as string w.String(string(v)) } else { // &amp;#34;invalid&amp;#34; text is marshalled as binary data w.Raw(json.Marshal([]byte(v))) } } Note, the code above is a marshaller for github.com/mailru/easyjson, which we use in the project.
Here is how it looks in practice:
func main() { v, _ := json.Marshal(struct { Resp1 interface{} `json:&amp;#34;resp1,omitempty&amp;#34;` Resp2 interface{} `json:&amp;#34;resp2,omitempty&amp;#34;` }{ Resp1: RawText(bin), // wrap the bin data into RawText Rest2: RawText(&amp;#34;normal string&amp;#34;), // wrap (copy) a string into RawText }) fmt.Printf(&amp;#34;%s\n&amp;#34;, v) // Output: // { // &amp;#34;resp1&amp;#34;:&amp;#34;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;#34;, // &amp;#34;resp2&amp;#34;:&amp;#34;normal string&amp;#34; // } }</description></item><item><title>Does profefe prefers "push" over "pull"?</title><link>https://vladimir.varank.in/notes/2020/08/does-profefe-prefers-push-over-pull/</link><pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/08/does-profefe-prefers-push-over-pull/</guid><description>The main component of profefe, a system for continuous profiling, is profefe-collector ‚Äî a service that receives profiling data, taken from an application and persists the data in collector‚Äôs storage (design document describes it in more details). Receiving data from an external source (for example, profefe-agent), indicates that profefe, as an observability system, prefers &amp;ldquo;push&amp;rdquo; model. Why not &amp;ldquo;pulling&amp;rdquo; the profiles directly from the application?
Both push and pull models have their benefits and drawbacks.
A collector that pulls profiling data from running applications could simplify integration into existing infrastructure because there would be no need in making changes in the applications that already exposed pprof HTTP endpoint. Making sure that every application integrated and configured profefe-agent would be a challenging job in a large organisation.
On the other hand, pull model requires pprof servers to be exposed and available for the collector, so it could fetch (pull) profiling data. That can also be challenging in the deployments, where applications are collocated on the bare-metal machines. Every application (application&amp;rsquo;s instance) would have to communicate a unique TCP port for its pprof server.
To work as a pull-system, the collector must be able to discover the pprof servers, thus it requires a mechanism for service discovery (SD), to be usable at scale. Unfortunately, there isn&amp;rsquo;t a universal SD protocol or a provider, an observability system could be built upon.
Prometheus, the best example of an open-source system, which uses pull model for data collection, have to support several different SD systems in their code base. At some point they ended up introducing their own general protocol, that expects a &amp;ldquo;middle-man-service&amp;rdquo;, which translates the data from a SD system into a list of Prometheus targets (Update, this comment from u/bbrazil does a better job explaining the state of SD in Prometheus). There is no clear way for an open-source system to be both flexible and don&amp;rsquo;t end up being a pile of &amp;ldquo;plugins&amp;rdquo;, that no one is willing to maintain or break.
From the start of profefe project, several years ago, I had the idea that translating push into pull would be easier for an end-user. That is if a small deployment already exposes a pprof server, writing an external job that pulls the profiles from the applications, annotates them with meta-data, and pushes the data into the collector, can be as easy as spawning a cronjob in a sidecar. kube-profefe solves that nicely for deployments running in Kubernetes. At some point, I hoped to come up with something similar for Nomad+Consul if the experiments ended successfully.
Translating pull into push is a similarly possible but because profefe didn‚Äôt have to support any SD mechanisms from the start, that simplified the overall code base and allowed us to focus on the collector and the API for profiles quering.
profefe-collector does uses push model. But one can deploy profefe so it reflected the use cases your organisation has.
Do you use continuous profiling? Let me know about your experience. Share your thoughts on Twitter or discuss on r/golang.</description></item><item><title>What's in your main-dot-go? (aka Go Project boilerplate)</title><link>https://vladimir.varank.in/notes/2020/07/whats-in-your-main-dot-go/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/07/whats-in-your-main-dot-go/</guid><description>Sometimes I write small services in Go from scratch. And every time main.go ends up looking almost the same:
func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() sigs := make(chan os.Signal, 2) signal.Notify(sigs, os.Interrupt, syscall.SIGTERM) go func() { &amp;lt;-sigs signal.Stop(sigs) cancel() }() if err := run(ctx, os.Args[1:]); err != nil { log.Fatalln(err) } } type Config struct { HTTPAddr string HTTPShutdownTimeout time.Duration } func run(ctx context.Context, args []string) error { flags := flag.NewFlagSet(&amp;#34;&amp;#34;, flag.ExitOnError) var conf Config flags.StringVar(&amp;amp;conf.HTTPAddr, &amp;#34;http-addr&amp;#34;, &amp;#34;127.0.0.1:10080&amp;#34;, &amp;#34;address to listen on&amp;#34;) flags.DurationVar(&amp;amp;conf.HTTPShutdownTimeout, &amp;#34;http-shutdown-timeout&amp;#34;, 5*time.Second, &amp;#34;server shutdown timeout&amp;#34;) if err := flags.Parse(args); err != nil { return err } // TODO: define the handler, the routing, and wire the dependencies with the main context mux := http.NewServeMux() server := &amp;amp;http.Server{ Addr: conf.HTTPAddr, Handler: mux, } errs := make(chan error, 1) go func() { log.Printf(&amp;#34;starting: addr %s&amp;#34;, server.Addr) errs &amp;lt;- server.ListenAndServe() }() select { case &amp;lt;-ctx.Done(): log.Println(&amp;#34;exiting...&amp;#34;) case err := &amp;lt;-errs: return err } // create new context because top-most one is already canceled ctx, cancel := context.WithTimeout(context.Background(), conf.HTTPShutdownTimeout) defer cancel() return server.Shutdown(ctx) } Of course, not every service requires an HTTP server, but the general idea stands.
When Go will introduce signal.NotifyContext(), the signals handling in main() function will be much smaller (we&amp;rsquo;re at go1.15rc1 as I&amp;rsquo;m writing that and the change hasn&amp;rsquo;t landed into the release yet).
I love how transparent is the flow here and how everything is scoped inside run() function. This structure forces you to eliminate global state, making unit or integration testing almost trivial ‚Äî at least, in theory ;)
It might feel like too much of boilerplate code for a &amp;ldquo;small&amp;rdquo; service. In practice, though, I don&amp;rsquo;t recall any time this caused any real troubles to me. The beauty of Go is in explicitness.</description></item><item><title>Retrieve Location of macOS Device from Go</title><link>https://vladimir.varank.in/notes/2020/03/go-osx-core-location/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/03/go-osx-core-location/</guid><description>&lt;p>Participating in self-isolation is more fun when you have toys to play. As a fun weekend project, I wanted to look at how one accesses macOS Location Services and get the geographic location of the device from Go.&lt;/p>
&lt;p>To obtain the geographic location of a device on macOS, we use &lt;a href="https://developer.apple.com/documentation/corelocation?language=objc">Apple‚Äôs Core Location&lt;/a> framework. The framework is part of the OS, but it requires writting Objective-C (&lt;em>or Swift&lt;/em>). Thanks to Go&amp;rsquo;s cgo and because Objective-C is from the family of C languages, we can write a bridge between Objective-C and Go.&lt;/p></description></item><item><title>[]byte to string conversion</title><link>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</link><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</guid><description>Go has an old wiki page, titled &amp;ldquo;Compiler And Runtime Optimizations&amp;rdquo;.
The part I like most there is different cases where compiler doesn&amp;rsquo;t allocate memory for string to []byte conversions:
For a map m of type map[string]T and []byte b, m[string(b)] doesn&amp;rsquo;t allocate (the temporary string copy of the byte slice isn&amp;rsquo;t made)
Turned out, since this wiki page was written, more similar optimisations were added to the compiler.
As it&amp;rsquo;s in Go 1.12+ the following cases are also listed in runtime/string.go:
Strings comcatenation For the case &amp;quot;&amp;lt;&amp;quot; + string(b) + &amp;quot;&amp;gt;&amp;quot;, where b is []byte no extra copying of b is needed.
Comparison if string(b) == &amp;#34;foo&amp;#34; { ¬∑¬∑¬∑ } In the code above, b []byte also won&amp;rsquo;t be copied.
There are still cases where compiler can&amp;rsquo;t optimise the code for us. In some of those cases it&amp;rsquo;s fine to do string to bytes conversion using a so called &amp;ldquo;unsafe trick&amp;rdquo; (accessing string&amp;rsquo;s underling data directly, with out copying the data from string to bytes and vice versa). One can find several ways of performing the trick, but none of them seems &amp;ldquo;the one that must be used&amp;rdquo;.
After years of episodic discussions, a collegue of mine assembled the list of different conserns and about the proper way of doing it (see &amp;ldquo;unsafe conversion between string &amp;lt;-&amp;gt; []byte&amp;rdquo; topic on golang-nuts forum). Thanks to replies from Go team, our most valid way of doing it is following:
// Refer to github.com/fmstephe/unsafeutil type stringHeader struct { data unsafe.Pointer stringLen int } type sliceHeader struct { data unsafe.Pointer sliceLen int sliceCap int } func StringToBytes(s string) (b []byte) { stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) sliceHeader.data = stringHeader.data sliceHeader.sliceLen = len(s) sliceHeader.sliceCap = len(s) return b } func BytesToString(b []byte) (s string) { sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) stringHeader.data = sliceHeader.data stringHeader.stringLen = len(b) return s }</description></item><item><title>Github Actions and GOPATH</title><link>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</guid><description>The other day I received my beta access to GitHub Actions. To try them out I picked an existing pet project and created a workflow using a Go project template provided by GitHub. As it&amp;rsquo;s in September 2019, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.
My project is a classic Go service ;) meaning: it uses vendoring and doesn&amp;rsquo;t use Go modules. So no need for &amp;ldquo;get dependencies&amp;rdquo; step. And it requires to be inside the GOPATH. With that, the provided workflow needed some adjustment.
After some trials and errors, I&amp;rsquo;ve managed to make checkout step to clone the repo into the correct destination inside the GOPATH. Here is the final workflow:
name: Run Go test on: [pull_request] jobs: test: strategy: matrix: go-version: [1.12.9] runs-on: ubuntu-latest steps: - uses: actions/setup-go@v1 with: go-version: ${{ matrix.go-version }} - uses: actions/checkout@v1 with: path: ./src/github.com/${{ github.repository }} fetch-depth: 5 - run: make test env: GOPATH: ${{ runner.workspace }} Note, how actions/checkout@v1 above uses custom path input parameter. I set the path to ./src/github.com/${{ github.repository }}, so the project is checked out to src directory in the runners&amp;rsquo;s workspace, which I later pass as the value of GOPATH to the &amp;ldquo;make test&amp;rdquo; step. The leading dot in ./src seems very important ‚Äî I&amp;rsquo;ve spent the majority of the time trying to figure out that part ‚Äî refer to this issue.
See the workflow in action.
To learn more about those ${{ ¬∑¬∑¬∑ }} &amp;ldquo;macroses&amp;rdquo; I suggest looking at the Actions&amp;rsquo; &amp;ldquo;Contexts and expression syntax&amp;rdquo; documentation.</description></item><item><title>Go's net/http.Headers</title><link>https://vladimir.varank.in/notes/2019/09/go-http-headers/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/go-http-headers/</guid><description>One probably knows that net/http.Headers is no more than map[string][]string with extra specific methods. A usual way to initialize and populate such data-structure from an external representation is something like that:
type Header map[string][]string func (h Header) Add(key, val string) { if val == &amp;#34;&amp;#34; { return } h[key] = append(h[key], val) } func main() { h := make(Header) h.Add(&amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;b.example.com&amp;#34;) } From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&amp;rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&amp;rsquo;d like to avoid.
I was curious to know if Go&amp;rsquo;s standard library cares about that.
Looking at the implementation of net/textproto.Reader.ReadMIMEHeader(), which is used in the standard HTTP server, or Go 1.13‚Äôs new net/http.Header.Clone(), it turned out they solve the problem quite elegantly.
We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.
Knowing that, we can refactor the initial Header.Add as the following:
type Header map[string][]string func (h Header) add(vv []string, key, val string) []string { if val == &amp;#34;&amp;#34; { ¬∑¬∑¬∑ } // fast path for KV pair of a single value if h[key] == nil { vv = append(vv, value) h[key] = vv[:1:1] return vv[1:] } // slow path, when KV pair has two or more values h[key] = append(h[key], val) return vv } func main() { h := make(Header) // net/textprotocol pre-counts total number of request&amp;#39;s headers // to allocate the slice of known capacity vv := make([]string, 0) vv = h.add(vv, &amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) vv = h.add(vv, &amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) } Note that we use vv[:1:1] to create a sub-slice of a fixed capacity (length 1, capacity 1).
If there is a KV-pair that has several values, e.g. &amp;ldquo;Via&amp;rdquo; header, Add will allocate a separate slice for that key, doubling its capacity.</description></item></channel></rss>