<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta http-equiv=x-ua-compatible content="ie=edge"><title>[]byte to string conversion - Vladimir Varankin</title><link rel=canonical href=https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/><meta property="og:title" content="[]byte to string conversion"><meta property="og:description" content="Go has an old wiki page, titled &ldquo;Compiler And Runtime Optimizations&#34;.
The part I like most there is different cases where compiler doesn&rsquo;t allocate memory for string to []byte conversions:
 For a map m of type map[string]T and []byte b, m[string(b)] doesn&rsquo;t allocate (the temporary string copy of the byte slice isn&rsquo;t made)
 Turned out, since this wiki page was written, more similar optimisations were added to the compiler.
As it&rsquo;s in Go 1.12+ the following cases are also listed in runtime/string.go:
 Strings comcatenation  For the case &#34;<&#34; + string(b) + &#34;>&#34;, where b is []byte no extra copying of b is needed.
 Comparison  if string(b) == &#34;foo&#34; { ··· } In the code above, b []byte also won&rsquo;t be copied.
 There are still cases where compiler can&rsquo;t optimise the code for us. In some of those cases it&rsquo;s fine to do string to bytes conversion using a so called &ldquo;unsafe trick&rdquo; (accessing string&rsquo;s underling data directly, with out copying the data from string to bytes and vice versa). One can find several ways of performing the trick, but none of them seems &ldquo;the one that must be used&rdquo;.
After years of episodic discussions, a collegue of mine assembled the list of different conserns and about the proper way of doing it (see &ldquo;unsafe conversion between string <-> []byte&rdquo; topic on golang-nuts forum). Thanks to replies from Go team, our most valid way of doing it is following:
// Refer to github.com/fmstephe/unsafeutil type stringHeader struct { data unsafe.Pointer stringLen int } type sliceHeader struct { data unsafe.Pointer sliceLen int sliceCap int } func StringToBytes(s string) (b []byte) { stringHeader := (*stringHeader)(unsafe.Pointer(&s)) sliceHeader := (*sliceHeader)(unsafe.Pointer(&b)) sliceHeader.data = stringHeader.data sliceHeader.sliceLen = len(s) sliceHeader.sliceCap = len(s) return b } func BytesToString(b []byte) (s string) { sliceHeader := (*sliceHeader)(unsafe.Pointer(&b)) stringHeader := (*stringHeader)(unsafe.Pointer(&s)) stringHeader.data = sliceHeader.data stringHeader.stringLen = len(b) return s }"><meta property="og:type" content="article"><meta property="og:url" content="https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/"><meta property="article:published_time" content="2019-10-08T00:00:00+00:00"><meta property="article:modified_time" content="2019-10-08T00:00:00+00:00"><style>:root{--background-color: #fff;--text-color: #111;--header-color: #111;--link-color: rgb(0, 16, 161);--link-underline-color: rgba(0, 16, 161, 0.3);--link-active-color: rgb(190, 0, 0);--link-active-underline-color: rgb(190, 0, 0)}@media(prefers-color-scheme:dark){:root{--background-color: #181818;--text-color: #cfcfcf;--header-color: #fefefe;--link-color: rgb(85, 172, 255);--link-underline-color: rgb(85, 172, 255, 0.8);--link-active-color: rgb(231, 66, 66);--link-active-underline-color: rgb(231, 66, 66)}}body{background:var(--background-color);color:var(--text-color);font-family:Charter,Georgia,serif;font-size:16px;line-height:1.45;margin:5px 12px}h1,h2,h3,h4{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color)}a:hover,a:active{color:#be0000;color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}ul,ol{max-width:840px;padding:0}ul>li{list-style:none;margin:.5em 0}pre{line-height:1.3}code{font-family:Menlo,Consolas,monospace;font-size:14px}pre code{font-size:13px}hr{border:none;border-bottom:1px solid;width:90%}.main-nav{display:flex;letter-spacing:.3em;padding-bottom:16px}.main-nav a,.main-nav span{margin-right:.6em;letter-spacing:0}.main-nav-item-active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.main-content{max-width:900px}.main-footer{margin:50px 0 0}.article{margin:0 0 50px}.article-meta{font-size:14px;line-height:1;padding:5px 0 0}.tag{margin:0 0 0 7px}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes/ class=main-nav-item-active>Notes</a>
<a href=/publications/>Publications</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=main-head><h1>[]byte to string conversion</h1></header><p>Go has an old wiki page, titled &ldquo;<a href=https://github.com/golang/go/wiki/CompilerOptimizations>Compiler And Runtime Optimizations</a>".</p><p>The part I like most there is different cases where compiler doesn&rsquo;t allocate memory for <code>string</code> to <code>[]byte</code> conversions:</p><blockquote><p>For a map m of type <code>map[string]T</code> and <code>[]byte b</code>, <code>m[string(b)]</code> doesn&rsquo;t allocate (the temporary string copy of the byte slice isn&rsquo;t made)</p></blockquote><p>Turned out, since this wiki page was written, more similar optimisations were added to the compiler.</p><p>As it&rsquo;s in Go 1.12+ the following cases are also listed in <a href=https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/string.go#L128-L153><code>runtime/string.go</code></a>:</p><ul><li>Strings comcatenation</li></ul><p>For the case <code>"&lt;" + string(b) + ">"</code>, where <code>b</code> is <code>[]byte</code> no extra copying of <code>b</code> is needed.</p><ul><li>Comparison</li></ul><pre><code>if string(b) == &quot;foo&quot; { ··· }
</code></pre><p>In the code above, <code>b []byte</code> also won&rsquo;t be copied.</p><hr><p>There are still cases where compiler can&rsquo;t optimise the code for us. In some of those cases
it&rsquo;s fine to do string to bytes conversion using a so called &ldquo;<code>unsafe</code> trick&rdquo; (accessing string&rsquo;s underling
data directly, with out copying the data from string to bytes and vice versa). One can find several
ways of performing the trick, but none of them seems &ldquo;the one that must be used&rdquo;.</p><p>After years of episodic discussions, a collegue of mine assembled the list of different conserns and about
the proper way of doing it (<em>see &ldquo;<a href=https://groups.google.com/d/topic/golang-nuts/Zsfk-VMd_fU/discussion>unsafe conversion between string &lt;-> []byte</a>&rdquo; topic on golang-nuts forum</em>).
Thanks to replies from Go team, our most valid way of doing it is following:</p><pre><code>// Refer to github.com/fmstephe/unsafeutil

type stringHeader struct {
	data      unsafe.Pointer
	stringLen int
}

type sliceHeader struct {
	data     unsafe.Pointer
	sliceLen int
	sliceCap int
}

func StringToBytes(s string) (b []byte) {
	stringHeader := (*stringHeader)(unsafe.Pointer(&amp;s))
	sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;b))
	sliceHeader.data = stringHeader.data
	sliceHeader.sliceLen = len(s)
	sliceHeader.sliceCap = len(s)
	return b
}

func BytesToString(b []byte) (s string) {
	sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;b))
	stringHeader := (*stringHeader)(unsafe.Pointer(&amp;s))
	stringHeader.data = sliceHeader.data
	stringHeader.stringLen = len(b)
	return s
}
</code></pre><footer class=article-meta><time datetime=2019-10-08T12:00:00Z>October 8, 2019</time><span class=tag>go</span><span class=tag>µ-benchmarks</span></footer></main><footer class=main-footer>© 2020 #SocialDistancing</footer><script type=text/javascript>(function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})(window,document,"script","https://mc.yandex.ru/metrika/tag.js","ym");ym(61655782,"init",{clickmap:true,trackLinks:true,accurateTrackBounce:true});</script><noscript><div><img src=https://mc.yandex.ru/watch/61655782 style=position:absolute;left:-9999px alt></div></noscript></body></html>