<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Go's net/http.Headers - Vladimir Varankin</title><style>:root{--background-color: #fff;--text-color: #111;--header-color: #111;--link-color: rgb(0, 16, 161);--link-underline-color: rgba(0, 16, 161, 0.3);--link-hover-color: rgb(190, 0, 0);--link-hover-underline-color: rgba(190, 0, 0, 0.3)}@media(prefers-color-scheme:dark){:root.theme-dark{--background-color: #181818;--text-color: #cfcfcf;--header-color: #fefefe;--link-color: rgb(85, 172, 255);--link-underline-color: rgb(85, 172, 255, 0.8);--link-hover-color: rgb(231, 66, 66);--link-hover-underline-color: rgb(231, 66, 66, 0.8)}}body{background:var(--background-color);color:var(--text-color);font-family:Charter,Georgia,serif;font-size:16px;line-height:1.45;margin:8px 12px}h1,h2,h3,h4{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color)}a:hover,a:active{color:#be0000;color:var(--link-hover-color);text-decoration-color:var(--link-hover-underline-color)}pre{line-height:1.3}code{font-family:Menlo,Consolas,monospace;font-size:14px}hr{border:none;border-bottom:1px solid;width:90%}.main-nav{letter-spacing:.3em;padding-bottom:16px}.main-nav a,.main-nav span{letter-spacing:0}.main-content{max-width:900px}.main-footer{margin:50px 0 0}.article{margin:0 0 50px}.article-meta{font-size:14px;line-height:1}.tag{margin:0 0 0 .5em}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes>Notes</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=main-head><h1>Go's net/http.Headers</h1></header><p>One probably knows that <code>net/http.Headers</code> is no more than <code>map[string][]string</code> with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>type</span> Header <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>][]<span style=color:#2b91af>string</span>

<span style=color:#00f>func</span> (h Header) Add(key, val <span style=color:#2b91af>string</span>) {
    <span style=color:#00f>if</span> val == <span style=color:#a31515>&#34;&#34;</span> {
        <span style=color:#00f>return</span>
    }
    h[key] = append(h[key], val)
}

<span style=color:#00f>func</span> main() {
    h := make(Header)
    h.Add(<span style=color:#a31515>&#34;Host&#34;</span>, <span style=color:#a31515>&#34;example.com&#34;</span>)
    h.Add(<span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;a.example.com&#34;</span>)
    h.Add(<span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;b.example.com&#34;</span>)
}
</code></pre></div><p>From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that're automatically parsed for every incoming request, this bunch of tiny allocations is something we'd like to avoid.</p><p>I was curious to know if Go's standard library cares about that.</p><p>Looking at the implementation of <a href=https://golang.org/pkg/net/textproto/#Reader.ReadMIMEHeader><code>net/textproto.Reader.ReadMIMEHeader()</code></a>, which's used in the standard
HTTP server, or Go 1.13’s new <a href=https://golang.org/pkg/net/http/#Header.Clone><code>net/http.Header.Copy()</code></a>, it turned out they solve the problem quit elegantly.</p><p>We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.</p><p>Knowing that, we can refactor the initial <code>Header.Add</code> as the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>type</span> Header <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>][]<span style=color:#2b91af>string</span>

<span style=color:#00f>func</span> (h Header) add(vv []<span style=color:#2b91af>string</span>, key, val <span style=color:#2b91af>string</span>) []<span style=color:#2b91af>string</span> {
    <span style=color:#00f>if</span> val == <span style=color:#a31515>&#34;&#34;</span> { <span>·</span><span>·</span><span>·</span> }

    <span style=color:green>// fast path for KV pair of a single value
</span><span style=color:green></span>    <span style=color:#00f>if</span> h[key] == <span style=color:#00f>nil</span> {
        vv = append(vv, value)
        h[key] = vv[:1:1]
        <span style=color:#00f>return</span> vv[1:]
    }

    <span style=color:green>// slow path, when KV pair has two or more values
</span><span style=color:green></span>    h[key] = append(h[key], val)
    <span style=color:#00f>return</span> vv
}

<span style=color:#00f>func</span> main() {
    h := make(Header)
    <span style=color:green>// net/textprotocol pre-counts total number of request&#39;s headers
</span><span style=color:green></span>    <span style=color:green>// to allocate the slice of known capacity
</span><span style=color:green></span>    vv := make([]<span style=color:#2b91af>string</span>, 0)

    vv = h.add(vv, <span style=color:#a31515>&#34;Host&#34;</span>, <span style=color:#a31515>&#34;example.com&#34;</span>)
    vv = h.add(vv, <span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;a.example.com&#34;</span>)
}
</code></pre></div><p>Note that we use <code>vv[:1:1]</code> to create a <a href=https://golang.org/ref/spec#Slice_expressions>subslice of the fixed capacity</a> (length 1, capacity 1).</p><p>If there is a KV-pair that has several values, e.g. &ldquo;Via&rdquo; header, <code>Add</code> will allocate a separate slice for that key, doubling its capacity.</p><footer class=article-meta><time datetime=2019-09-04T12:00:00Z>September 4, 2019</time><span class=tag>go</span><span class=tag>µ-benchmarks</span></footer></main><footer class=main-footer>© 2019 VLDMR</footer></body></html>