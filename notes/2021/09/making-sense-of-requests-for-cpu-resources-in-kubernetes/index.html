<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=color-scheme content="light dark">
<meta http-equiv=x-ua-compatible content="ie=edge">
<title>Making sense of requests for CPU resources in Kubernetes - Vladimir Varankin</title>
<link rel=canonical href=https://vladimir.varank.in/notes/2021/09/making-sense-of-requests-for-cpu-resources-in-kubernetes/>
<meta property="og:title" content="Making sense of requests for CPU resources in Kubernetes">
<meta property="og:description" content="Kubernetes allows a container to request several resource types:
apiVersion: v1 kind: Pod metadata: name: my-app spec: containers: - name: my-app image: images.example/my-app resources: requests: cpu: &#34;100m&#34; memory: &#34;64Mi&#34; limits: cpu: &#34;500m&#34; memory: &#34;128Mi&#34; One particularly confusing type of the resource for me was cpu. For example, in the manifest above, the my-app container declares a request for &ldquo;100m&rdquo; of the CPU. What does that mean?
Kubernetes&rsquo;s documentation on managing containers resources describes that as following:
 Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. CPU is always requested as an absolute quantity, never as a relative quantity; 0.1 is the same amount of CPU on a single-core, dual-core, or 48-core machine.
 A misleading (but fairly common) mental modal amongst the developers, is that the application inside the Pod&rsquo;s container is &ldquo;boxed&rdquo; by the container runtime, as if the application received a dedicated slice of the machine&rsquo;s resources. That&rsquo;s not exactly how it works. At least, it&rsquo;s not if Kubernetes uses Docker as the underlying container runtime.
I find it easier to think about the requested resources as a way for an application to &ldquo;hint&rdquo; to Kubernetes scheduler about how much resources the application thinks it needs.
Kubernetes scheduler keeps the &ldquo;accounting&rdquo; for how much of total resources the tenants of the cluster requested, and how much the cluster&rsquo;s machines have to offer. It&rsquo;s important to stress that the &ldquo;accounting&rdquo; is done only base on the requests for the resources. That is, the scheduler doesn&rsquo;t check if the container uses the resources it requested. If a container requested more than half of the node&rsquo;s CPU resources, e.g. &ldquo;1100m&rdquo; on a 2 vCPU node, Kubernetes won&rsquo;t deploy more than a single replica of this container to that node, nomatter if the application inside the container is idle.
 Each node has a maximum capacity for each of the resource types: the amount of CPU and memory it can provide for Pods. The scheduler ensures that, for each resource type, the sum of the resource requests of the scheduled containers is less than the capacity of the node. Note that although actual memory or CPU resource usage on nodes is very low, the scheduler still refuses to place a Pod on a node if the capacity check fails.
 What has been requested, has been booked.
Of course, &ldquo;accounting&rdquo; of the existing resources is only half of the story. In the same documentation about managing containers resources, they talk about the implementation details of what happens after a container gets scheduled to a node, refering to Docker&rsquo;s documentation about CPU share constraint. This details for how Docker itself juggles the CPU shares between the running containers can be even more confusing but the interesting part to remember is the following:
 The proportion [of CPU cycles] will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. [..] On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is limited to less than 100% of CPU time, it can use 100% of each individual CPU core.
 The important difference between the ideas of a &ldquo;box&rdquo; and a &ldquo;hint&rdquo; is that the &ldquo;hint&rdquo; doesn&rsquo;t prevent the application from consuming the whole node&rsquo;s CPU resources, when it requested only half of it — containers are not the VMs, afterall. Using the same example of a cluster&rsquo;s node with 2 vCPU, a multi-threaded application inside a container still sees two CPU cores. If there are no other tenants on the node, there is no one who the application has to compete for its share of CPU resources.
As mentioned earlier, this applies to Docker container runtime. Don&rsquo;t forget to consult with the documentation provided by the particular Kubernetes distribution when you make the decisions, that includes the fine-tunning of cluster resources. Docker is still the runtime AWS EKS uses for Kubernetes up to version 1.21. But things might work differently for your cluster as Kubernetes providers switch to alternative container runtimes.
Let&rsquo;s discuss this note on Hacker News and Twitter.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://vladimir.varank.in/notes/2021/09/making-sense-of-requests-for-cpu-resources-in-kubernetes/"><meta property="article:section" content="notes">
<meta property="article:published_time" content="2021-09-26T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-26T00:00:00+00:00">
<style>:root{--background-color:#fff;--text-color:rgb(19, 19, 19);--text-underline-color:rgba(19, 19, 19, 0.5);--header-color:#111;--hr-color:rgb(143, 150, 163);--link-color:rgb(0, 16, 161);--link-underline-color:rgba(0, 16, 161, 0.3);--link-active-color:rgb(231, 19, 19);--link-active-underline-color:rgba(231, 19, 19, 0.7);--tag-color:rgb(85, 63, 63);--tag-underline-color:rgba(85, 63, 63, 0.5)}html{font-size:16px;height:100%;margin:0;padding:0}body{background:var(--background-color);color:var(--text-color);display:grid;grid-template-rows:auto 1fr auto;font-family:Charter,Georgia,serif;font-size:1.1rem;line-height:1.3;margin:5px 1%;margin:5px max(7px,1%);margin:5px clamp(7px,1.5vw,14px);min-height:calc(100vh - 10px)}h1,h2,h3,h4,h5,h6{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1;margin:1.5em 0 .7em}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color);text-decoration-thickness:.04em;text-underline-offset:.1em}a:hover,a:active{color:#be0000;color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}ul,ol{box-sizing:border-box;max-width:760px;padding:0}ol{padding-left:1.2em}ul>li{list-style:none;margin:.5em 0}figure{margin:0;margin-block-start:1em;margin-block-end:1em;padding:0}pre{line-height:1.1;margin:2em 1em}code{font-family:sf mono,Menlo,Consolas,monospace;font-size:16px}pre code{font-size:15px;tab-size:4}hr{color:var(--hr-color);border:none;border-bottom:1px solid;margin:.5em 0;width:76%}.site-nav{display:flex;flex-wrap:wrap;letter-spacing:.3em;padding-bottom:16px}.site-nav a,.site-nav span{margin-right:.6em;letter-spacing:0}.site-nav-item-active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.site-content{font-size:19px;max-width:940px}.site-content img{max-width:100%;max-width:calc(100vw - 15px)}.site-content pre{max-width:calc(100vw - 2em);overflow-x:visible}.site-footer{font-size:14px;margin:50px 0 0}.site-footer a{color:var(--text-color);text-decoration-color:inherit;text-decoration-color:var(--text-underline-color)}.main-head{display:flex;align-items:baseline;gap:8px}.main-head-meta{font-size:16px;margin:0;padding:0}.main-head-meta a{color:var(--text-color);text-decoration-color:inherit;text-decoration-color:var(--text-underline-color);margin:0 5px 0 0}.main-head-meta a:hover,.main-head-meta a:active{color:var(--link-active-color);text-decoration-color:var(--link-active-underline-color)}.article{margin:0 0 50px}.article:last-child{margin-bottom:0}.section-head{font-size:28px}.section-head h1,.section-head h2{font-size:1em;margin-top:1em}.section-head h2{margin-bottom:0}.snippet{margin:0 0 40px}.snippet:last-of-type{margin:0}.snippet p{margin:0 0 .3em}.snippet-head h2{font-size:21px;margin:1em 0 .2em}.meta{font-size:14px;line-height:1;padding:5px 0 0}.tag{color:var(--tag-color);text-decoration-color:var(--tag-underline-color);margin:0 0 0 7px;text-transform:lowercase}.meta-topics-list{line-height:1.4;padding:34px 0 0}.meta-topics-list .tag{display:inline-block;margin:0 1ex 0 0}.glitch:before{background:var(--background-color);position:absolute;content:attr(data-text);clip:rect(0,900px,0,0);animation:glitch-anim 2s infinite linear alternate-reverse;margin-left:-5px;text-shadow:1px 0 red}@media(prefers-reduced-motion){.glitch:before{display:none}}@keyframes glitch-anim{0%{clip:rect(3px,9999px,93px,0)}5%{clip:rect(53px,9999px,78px,0)}10%{clip:rect(10px,9999px,75px,0)}15%{clip:rect(32px,9999px,40px,0)}20%{clip:rect(65px,9999px,62px,0)}25%{clip:rect(31px,9999px,14px,0)}30%{clip:rect(94px,9999px,87px,0)}35%{clip:rect(81px,9999px,41px,0)}40%{clip:rect(45px,9999px,50px,0)}45%{clip:rect(82px,9999px,41px,0)}50%{clip:rect(71px,9999px,3px,0)}55%{clip:rect(75px,9999px,60px,0)}60%{clip:rect(20px,9999px,49px,0)}65%{clip:rect(67px,9999px,92px,0)}70%{clip:rect(47px,9999px,55px,0)}75%{clip:rect(63px,9999px,90px,0)}80%{clip:rect(70px,9999px,92px,0)}85%{clip:rect(41px,9999px,60px,0)}90%{clip:rect(56px,9999px,79px,0)}95%{clip:rect(21px,9999px,68px,0)}100%{clip:rect(15px,9999px,72px,0)}}</style>
</head>
<body>
<nav class=site-nav>
<a href=/ class=glitch data-text="Vladimir Varankin">Vladimir Varankin</a>
<a href=/notes/ class=site-nav-item-active>Notes</a>
<a href=/publications/>Publications</a>
<span> · </span>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://t.me/varankinv>Telegram</a>
<a href=https://keybase.io/varankinv>Keybase</a>
</nav>
<main class=site-content>
<header class=section-head>
<h1>Making sense of requests for CPU resources in Kubernetes</h1>
</header>
<p>Kubernetes allows a container to request several resource types:</p>
<pre tabindex=0><code>apiVersion: v1
kind: Pod
metadata:
  name: my-app
spec:
  containers:
  - name: my-app
    image: images.example/my-app
    resources:
      requests:
        cpu: &quot;100m&quot;
        memory: &quot;64Mi&quot;
      limits:
        cpu: &quot;500m&quot;
        memory: &quot;128Mi&quot;
</code></pre><p>One particularly confusing type of the resource for me was <code>cpu</code>. For example, in the manifest above, the <code>my-app</code> container declares a request for &ldquo;100m&rdquo; of the CPU. What does that mean?</p>
<p>Kubernetes&rsquo;s documentation on <a href=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>managing containers resources</a> describes that as following:</p>
<blockquote>
<p>Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors.
CPU is always requested as an absolute quantity, never as a relative quantity; 0.1 is the same amount of CPU on a single-core, dual-core, or 48-core machine.</p>
</blockquote>
<p>A misleading (but fairly common) mental modal amongst the developers, is that the application inside the Pod&rsquo;s container is &ldquo;boxed&rdquo; by the container runtime, as if the application received a dedicated slice of the machine&rsquo;s resources. That&rsquo;s not exactly how it works. At least, it&rsquo;s not if Kubernetes uses Docker as the underlying container runtime.</p>
<p>I find it easier to think about the requested resources as a way for an application to &ldquo;hint&rdquo; to Kubernetes scheduler about how much resources the application <em>thinks</em> it needs.</p>
<p>Kubernetes scheduler keeps the &ldquo;accounting&rdquo; for how much of total resources the tenants of the cluster requested, and how much the cluster&rsquo;s machines have to offer. It&rsquo;s important to stress that the &ldquo;accounting&rdquo; is done only base on the requests for the resources. That is, the scheduler doesn&rsquo;t check if the container uses the resources it requested. If a container requested more than half of the node&rsquo;s CPU resources, e.g. &ldquo;1100m&rdquo; on a 2 vCPU node, Kubernetes won&rsquo;t deploy more than a single replica of this container to that node, nomatter if the application inside the container is idle.</p>
<blockquote>
<p>Each node has a maximum capacity for each of the resource types: the amount of CPU and memory it can provide for Pods. The scheduler ensures that, for each resource type, the sum of the resource requests of the scheduled containers is less than the capacity of the node. Note that although actual memory or CPU resource usage on nodes is very low, the scheduler still refuses to place a Pod on a node if the capacity check fails.</p>
</blockquote>
<p>What has been requested, has been booked.</p>
<p>Of course, &ldquo;accounting&rdquo; of the existing resources is only half of the story. In the same documentation about <a href=https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/>managing containers resources</a>, they talk about the implementation details of what happens after a container gets scheduled to a node, refering to Docker&rsquo;s documentation about <a href=https://docs.docker.com/engine/reference/run/#cpu-share-constraint>CPU share constraint</a>. This details for how Docker itself juggles the CPU shares between the running containers can be even more confusing but the interesting part to remember is the following:</p>
<blockquote>
<p>The proportion [of CPU cycles] will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. [..]
On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is limited to less than 100% of CPU time, it can use 100% of each individual CPU core.</p>
</blockquote>
<p>The important difference between the ideas of a &ldquo;box&rdquo; and a &ldquo;hint&rdquo; is that the &ldquo;hint&rdquo; doesn&rsquo;t prevent the application from consuming the whole node&rsquo;s CPU resources, when it requested only half of it — containers are not the VMs, afterall. Using the same example of a cluster&rsquo;s node with 2 vCPU, a multi-threaded application inside a container still sees two CPU cores. If there are no other tenants on the node, there is no one who the application has to compete for its share of CPU resources.</p>
<p>As mentioned earlier, this applies to Docker container runtime. Don&rsquo;t forget to consult with the documentation provided by the particular Kubernetes distribution when you make the decisions, that includes the fine-tunning of cluster resources. Docker is still the runtime AWS EKS uses for <a href=https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html>Kubernetes up to version 1.21</a>. But things might work differently for your cluster as Kubernetes providers switch to alternative container runtimes.</p>
<p><em>Let&rsquo;s discuss this note on <a href="https://news.ycombinator.com/item?id=28668859">Hacker News</a> and <a href=https://twitter.com/tvii/status/1442427866961088513>Twitter</a>.</em></p>
<footer class=meta>
<time datetime=2021-09-26T12:00:00Z>September 26, 2021</time><a class=tag href=/notes/kubernetes/>kubernetes</a><a class=tag href=/notes/docker/>docker</a>
</footer>
<section class="meta meta-topics-list">
<header class=meta-topics-list-title><h3>All topics</h3></header><a class=tag href=https://vladimir.varank.in/notes/aarch64/>aarch64</a><a class=tag href=https://vladimir.varank.in/notes/arduino/>arduino</a><a class=tag href=https://vladimir.varank.in/notes/arm64/>arm64</a><a class=tag href=https://vladimir.varank.in/notes/askme/>askme</a><a class=tag href=https://vladimir.varank.in/notes/berlin/>berlin</a><a class=tag href=https://vladimir.varank.in/notes/buildkit/>buildkit</a><a class=tag href=https://vladimir.varank.in/notes/cgo/>cgo</a><a class=tag href=https://vladimir.varank.in/notes/coffee/>coffee</a><a class=tag href=https://vladimir.varank.in/notes/continuous-profiling/>continuous profiling</a><a class=tag href=https://vladimir.varank.in/notes/covid-19/>COVID-19</a><a class=tag href=https://vladimir.varank.in/notes/design/>design</a><a class=tag href=https://vladimir.varank.in/notes/docker/>docker</a><a class=tag href=https://vladimir.varank.in/notes/e-paper/>e-paper</a><a class=tag href=https://vladimir.varank.in/notes/esp8266/>esp8266</a><a class=tag href=https://vladimir.varank.in/notes/firefox/>firefox</a><a class=tag href=https://vladimir.varank.in/notes/github-actions/>github actions</a><a class=tag href=https://vladimir.varank.in/notes/go/>Go</a><a class=tag href=https://vladimir.varank.in/notes/go-time-fm/>go time fm</a><a class=tag href=https://vladimir.varank.in/notes/homelab/>homelab</a><a class=tag href=https://vladimir.varank.in/notes/ipv6/>IPv6</a><a class=tag href=https://vladimir.varank.in/notes/k3s/>k3s</a><a class=tag href=https://vladimir.varank.in/notes/kubernetes/>kubernetes</a><a class=tag href=https://vladimir.varank.in/notes/macos/>macos</a><a class=tag href=https://vladimir.varank.in/notes/material-ui/>material ui</a><a class=tag href=https://vladimir.varank.in/notes/mdns/>mDNS</a><a class=tag href=https://vladimir.varank.in/notes/ndppd/>ndppd</a><a class=tag href=https://vladimir.varank.in/notes/objective-c/>objective-c</a><a class=tag href=https://vladimir.varank.in/notes/postgresql/>PostgreSQL</a><a class=tag href=https://vladimir.varank.in/notes/pprof/>pprof</a><a class=tag href=https://vladimir.varank.in/notes/profefe/>profefe</a><a class=tag href=https://vladimir.varank.in/notes/random/>random</a><a class=tag href=https://vladimir.varank.in/notes/raspberry-pi/>raspberry pi</a><a class=tag href=https://vladimir.varank.in/notes/travis-ci/>travis ci</a><a class=tag href=https://vladimir.varank.in/notes/vs-code/>vs code</a><a class=tag href=https://vladimir.varank.in/notes/waveshare/>waveshare</a><a class=tag href=https://vladimir.varank.in/notes/%C2%B5-benchmarks/>µ-benchmarks</a></section>
</main>
<footer class=site-footer>© 2019&#8230;2022 #SocialDistancing<br><a href=mailto:vladimir@varank.in>vladimir@varank.in</a></footer>
<img src=https://c.varank.in/hello/*https://vladimir.varank.in/notes/2021/09/making-sense-of-requests-for-cpu-resources-in-kubernetes/ style=position:absolute;left:-9999px decoding=async alt>
</body>
</html>