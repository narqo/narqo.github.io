<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Enum on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/enum/</link><description>Recent content in Enum on Vladimir Varankin</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 29 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/enum/index.xml" rel="self" type="application/rss+xml"/><item><title>Compile-time safety for enumerations in Go</title><link>https://vladimir.varank.in/notes/2023/09/compile-time-safety-for-enumerations-in-go/</link><pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2023/09/compile-time-safety-for-enumerations-in-go/</guid><description>&lt;p&gt;Last month, a colleague of mine asked how to reason about enumerated values (&amp;ldquo;enums&amp;rdquo;) in Go. They wanted to benefit from Go&amp;rsquo;s type-safety and to prevent users from misusing the package.&lt;/p&gt;
&lt;p&gt;For an imaginary example, that enumerates possible colours, the snippet below shows how we typically implement this:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;type Color string

const (
 Red Color = &amp;#34;red&amp;#34;
 Green Color = &amp;#34;green&amp;#34;
 Blue Color = &amp;#34;blue&amp;#34;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But, just like &lt;a href="https://twitter.com/goinggodotnet/"&gt;Bill Kennedy&lt;/a&gt; illustrated it in the &lt;a href="https://www.ardanlabs.com/blog/2023/09/implementing-enumerations-in-golang.html"&gt;blog post on a similar topic&lt;/a&gt;, such implementation allows a user to pass any &amp;ldquo;&lt;a href="https://go.dev/blog/constants#string-constants"&gt;untyped constant string&lt;/a&gt;&amp;rdquo; in places where the &lt;code&gt;Color&lt;/code&gt; type is expected. Also, a user can declare their own value of a type &lt;code&gt;Color&lt;/code&gt;, going beyond what was defined by the initial enumeration set.&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main

func main() {
 PrintColor(color.Red)

 PrintColor(&amp;#34;RAINBOW&amp;#34;)

 var rainbow color.Color = &amp;#34;üåà&amp;#34;
 PrintColor(rainbow)
}

func PrintColor(c color.Color) {
 fmt.Printf(&amp;#34;%v\n&amp;#34;, c)
}

// Outputs:
red
RAINBOW
üåà
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note how in the snippet above, the user both called &lt;code&gt;PrintColor(‚ÄúRAINBOW‚Äù)&lt;/code&gt; and defined their own variable of type &lt;code&gt;color.Color&lt;/code&gt;, which holds a random string.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Update: a number of people pointed at my choice of words in the paragraph below, where I introduce a way to solve the problems. Indeed, &amp;ldquo;elegant&amp;rdquo; isn&amp;rsquo;t the most accurate one to describe this solution :) Also, refer to &lt;a href="https://go.dev/issues/19412"&gt;#19412&lt;/a&gt; for the discussion about adding sum types to Go.&lt;/em&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Go&amp;rsquo;s type system allows preventing both issues &lt;del&gt;in a rather elegant way&lt;/del&gt;. Let&amp;rsquo;s declare the &lt;code&gt;Color&lt;/code&gt; interface, with an &lt;em&gt;unexported method&lt;/em&gt;, while implementing this interface in an unexported type &lt;code&gt;color&lt;/code&gt;:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package color

type Color interface {
 xxxProtected()
}

type color string

func (c color) xxxProtected() {}

const (
	Red color = &amp;#34;red&amp;#34;
	Green color = &amp;#34;green&amp;#34;
	Blue color = &amp;#34;blue&amp;#34;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Because no types outside of our package &lt;code&gt;color&lt;/code&gt; can implement the unexported method &lt;code&gt;color.Color.xxxProtected()&lt;/code&gt;, we limit the possible implementations of the &lt;code&gt;Color&lt;/code&gt; interface to only values, defined in the package &lt;code&gt;color&lt;/code&gt;.&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main

func main() {
 PrintColor(color.Red)

 //PrintColor(&amp;#34;RAINBOW&amp;#34;) // cannot use (constant of type string) as color.Color
}

func PrintColor(c color.Color) {
 fmt.Printf(&amp;#34;%v\n&amp;#34;, c)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;If a user tries to pass an untyped constant string or declare their own variant of the colour, the code won&amp;rsquo;t compile, resulting with an error:&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;package main

type mycolor string

func (c mycolor) xxxProtected() {}

func main() {
 black := mycolor(&amp;#34;BLACK&amp;#34;)
 PrintColor(black)
}

OUTPUTS:
./prog.go:9:13: cannot use black (variable of type mycolor) as color.Color value in argument to PrintColor:
mycolor does not implement color.Color (missing method xxxProtected)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;Have you stumbled upon a scenario, where such strict compile-time checks for enumerated values was needed? Share your thoughts with me on &lt;a href="https://news.ycombinator.com/item?id=37703175"&gt;Hacker News&lt;/a&gt; or &lt;a href="https://bsky.app/profile/vladimir.varank.in/post/3kajuu4lrn52b"&gt;Bluesky&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>