<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/</link><description>Recent content in Notes on Vladimir Varankin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 27 Jan 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Building Multi-Platform Docker Images with Travis CI and BuildKit</title><link>https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/</link><pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/</guid><description>This is a lengthy note. If you don&amp;rsquo;t quite feel reading and only need the working example, go directly to the Travis CI build file.
The more I delve into the world of Raspberry Pi, the more I notice that &amp;ldquo;regular and boring&amp;rdquo; things on ARM are harder than I expected.
People build and distribute software exclusively for amd64. You read another &amp;ldquo;Kubernetes something&amp;rdquo; tutorial, that went viral on Twitter, and is fancy to try it out. Still, all helm charts, or whatever the author prefered, use Docker images built exclusively for amd64.
Docker toolchain has added the support for building multi-platform images in 19.x. However, it&amp;rsquo;s available only under the &amp;ldquo;experimental&amp;rdquo; mode. The topic of building multi-platform Docker images yet feels underrepresented.
But first, what are multi-platform Docker images? When a client, e.g. Docker client, tries to pull an image, it must negotiate the details about what exactly to pull with the registry. The registry provides a manifest that describes the digest of the requested image, the volumes the image consists of, the platform this image can run on, etc. Optionally, the registry can provide a manifests list, which, as the name suggests, is a list of several manifests bundled into one. With the manifests list in hands, the client can figure out the particular digest of the image it needs to pull.
So multi-platform Docker images are just several images, whose manifests are bundled into the manifests list.
Imagine we want to pull the image golang:1.13.6-alpine3.10. Docker client will get the manifests list from Dockerhub. This list includes digests of several images, each built for the particular platform. If we&amp;rsquo;re on Raspberry Pi, running the current Raspbian Linux, which is arm/v7, the client will pick the corresponding image&amp;rsquo;s digest. Alternatively, we could choose to pull the image arm32v7/golang:1.13.6-alpine3.10 instead, and we ended up with the same image with the digest d72fa60fb5b9. Of course, to use a single universal image name, i.e. golang, on every platform is way more convenient.
You can read more about manifests in Docker registry documentation.
Does it mean I need to build different Docker images, for each platform I want to support? Well, yes. This is how, official images are built.
For every platform, the image is built and pushed to the registry under the name &amp;lt;platform&amp;gt;/&amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;, e.g. amd64/golang:1-alpine. And next, a manifests list, that combines all those platform-specific images, is built and pushed with the simple name &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;.
Docker&amp;rsquo;s BuildKit provides a toolkit that, among other nice things, allows building multi-platform images on a single host. BuildKit is used inside Docker&amp;rsquo; buildx project, that is part of the recent Docker version.
One can use buildx, but, for this post, I wanted to try out, what would it look like to use BuildKit directly. For profefe, the system for continuous profiling of Go services, I set up Travis CI, that builds a multi-platform Docker image and pushes them to Dockerhub.
profefe is written in Go. That simplifies things, because, thanks to Go compiler, I don&amp;rsquo;t have to think about how to compile code for different platforms. The same Dockerfile will work fine on every platform.
Here&amp;rsquo;s how &amp;ldquo;deploy&amp;rdquo; stage of the build job looks like (see travis.yml on profefe&amp;rsquo;s GitHub).
dist: bionic language: go go: - 1.x jobs: include: - stage: deploy docker services: docker env: - PLATFORMS=&amp;quot;linux/amd64,linux/arm64,linux/arm/v7&amp;quot; install: - docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes - docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest - sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/ - export BUILDKIT_HOST=&amp;quot;docker-container://buildkitd&amp;quot; script: skip deploy: - provider: script script: | buildctl build \ --progress=plain \ --frontend=dockerfile.v0 \ --local context=. --local dockerfile=. \ --opt filename=contrib/docker/Dockerfile \ --opt platform=$PLATFORMS \ --opt build-arg:VERSION=\&amp;quot;master\&amp;quot; \ --opt build-arg:GITSHA=\&amp;quot;$TRAVIS_COMMIT\&amp;quot; \ --output type=image,\&amp;quot;name=profefe/profefe:git-master\&amp;quot;,push=true on: repo: profefe/profefe branch: master before_deploy: - echo &amp;quot;$DOCKER_PASSWORD&amp;quot; | docker login --username &amp;quot;$DOCKER_USERNAME&amp;quot; --password-stdin after_failure: - buildctl debug workers ls - docker container logs buildkitd It&amp;rsquo;s a lot happening here, but I&amp;rsquo;ll describe the most critical parts.
Let&amp;rsquo;s start with dist: bionic.
We run the builds under Ubuntu 18.04 (Bionic Beaver). To be able to build multi-platform images on a single amd64 host, BuildKit uses QEMU to emulate other platforms. That requires Linux kernel 4.8, so even Ubuntu 16.04 (Xenial Xerus) should work.
The top-level details on how the emulation works are very well described in https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html
In short, we tell the component of the kernel (binfmt_misc) to use QEMU when the system executes a binaries built for a different platform. The following call in the &amp;ldquo;install&amp;rdquo; step is what&amp;rsquo;s doing that:
- docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes Under the hood, the container runs a shell script from QEMU project, that registers the emulator as an executor of binaries from the external platforms.
If you think, that running a docker container to do the manipulations with the host&amp;rsquo;s OS looks weird, well&amp;hellip; I can&amp;rsquo;t agree more. Probably, a better approach would be to install qemu-user-static, which would do the proper setup. Unfortunately, the current package&amp;rsquo;s version for Ubuntu Bionic doesn&amp;rsquo;t do the registration as we need it. I.e. its post-install doesn&amp;rsquo;t add the &amp;quot;F&amp;quot; flag (&amp;ldquo;fix binaries&amp;rdquo;), which is crucial for our goal. Let&amp;rsquo;s just agree,that docker-run will do ok for the demonstrational purpose.
- docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest - sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/ - export BUILDKIT_HOST=&amp;#34;docker-container://buildkitd&amp;#34; This is another &amp;ldquo;docker-run&amp;rsquo;ism&amp;rdquo;. We start BuildKit&amp;rsquo;s buildkitd daemon inside the container, attaching it to the Docker daemon that runs on the host (&amp;ldquo;privileged&amp;rdquo; mode). Next, we copy buildctl binary from the container to the host system and set BUILDKIT_HOST environment variable, so buildctl knew where its daemon runs.
Alternatively, we could install BuildKit from GitHub and run the daemon directly on the build host. YOLO.
before_deploy: - echo &amp;#34;$DOCKER_PASSWORD&amp;#34; | docker login --username &amp;#34;$DOCKER_USERNAME&amp;#34; --password-stdin To be able to push the images to the registry, we need to log in providing Docker credentials to host&amp;rsquo;s Docker daemon. The credentials are set as Travis CI&amp;rsquo;s encrypted environment variables ([refer to Travis CI docs])](https://docs.travis-ci.com/user/environment-variables/)).
buildctl build \ --progress=plain \ --frontend=dockerfile.v0 \ --local context=. --local dockerfile=. \ --opt filename=contrib/docker/Dockerfile \ --opt platform=$PLATFORMS \ --opt build-arg:VERSION=\&amp;quot;master\&amp;quot; \ --opt build-arg:GITSHA=\&amp;quot;$TRAVIS_COMMIT\&amp;quot; \ --output type=image,\&amp;quot;name=profefe/profefe:git-master\&amp;quot;,push=true This is the black box where everything happens. Magically!
We run buildctl stating that it must use the specified Dockerfile; it must build the images for defined platforms (I specified linux/amd64,linux/arm64,linux/arm/v7), create a manifests list tagged as the desired image (profefe/profefe:&amp;lt;version&amp;gt;), and push all the images to the registry.
buildctl debug workers ls shows what platforms does BuildKit on this host support. I listed only those I&amp;rsquo;m currently intrested with.
And that&amp;rsquo;s all. This setup automatically builds and pushes multi-platform Docker images for profefe (https://hub.docker.com/p/profefe/profefe) on a commit to project&amp;rsquo;s &amp;ldquo;master&amp;rdquo; branch on GitHub.
As I hope you&amp;rsquo;ve seen, support for multi-platform is getting easier and things that were hard a year ago are only mildly annoying now :)
If you have any comments or suggestions, reach out to me on Twitter or discuss this note on r/docker Reddit.
Some more reading on the topic:
Documentation for BuildKit project Building multi-platform images with docker and buildx Docker Official Images are now Multi-platform, Docker official announcement</description></item><item><title>k3s with Ubuntu Server (arm64) on Raspberry Pi 4</title><link>https://vladimir.varank.in/notes/2020/01/raspi-ubuntu-arm64-k3s/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/01/raspi-ubuntu-arm64-k3s/</guid><description>As I&amp;rsquo;ve twitted recently, I&amp;rsquo;m updating one of my Raspberry Pis to Ubuntu Server 19.10 (arm64).
&amp;ldquo;One of Raspberry Pis&amp;rdquo;? My home cluster is four Raspberry Pis 4 (2GB); all connected to my internet router through ethernet and powered with 60W 6 USB-ports charger. All Pis build a small kubernetes cluster that runs with k3s.
All by one Pis run on Raspbian Buster Lite and this setup&amp;rsquo;s been working pretty well until I&amp;rsquo;ve found out, Aerospike, a database I required to run for a testing lab, only works on a 64-bit OS.
Luckily, Ubuntu Server has an arm64 version built for Raspberry Pi. Thus, my working plan is to switch one Pi to Ubuntu, compile and run a single-instance Aerospike server (and any other components, that require a 64-bit OS) on this Pi, and provide a kubernetes service in front of the DB, so other components in the cluster could access it as if it was fully managed by kubernetes.
The Setup Setting up Ubuntu Server on a Pi was smooth. All I did was flushing the image with 19.10 OS to an SD card, as described in Ubuntu wiki. That is, the headless setup worked out of the box, and after I inserted the card into the PI and connected it to the router, I managed to SSH into the system:
$ ssh ubuntu@192.168.10.18 The default password for ubuntu user is ubuntu. The system asks to change the password on the first login.
The first thing to do after installing the system:
$ sudo apt-get update $ sudo apt-get upgrade -y Disable &amp;ldquo;message of the day&amp;rdquo; (motd) to speed SSH login. For that I commented out the following lines in /etc/pam.d/login and /etc/pam.d/sshd:
#session optional pam_motd.so motd=/run/motd.dynamic #session optional pam_motd.so noupdate Reduce GPU memory split. I truly don&amp;rsquo;t know if that even makes sense, tbh; read about memory split on Raspberry PI config-txt wiki. I added the following to /boot/firmware/usercfg.txt:
gpu_mem=16 To run Kubernetes or Docker, the kernel needs some cgroup options. On Ubuntu Server, the configuration is in /boot/firmware/nobtcmd.txt (refer to cmdline=nobtcmd.txt in /boot/firmware/nobtcfg.txt). Add the following to the end of the file:
cgroup_enable=cpuset cgroup_enable=memory cgroup_memory=1 Reboot the Pi, re-login, and all is ready to install k3s-agent:
$ curl -sfL https://get.k3s.io | K3S_URL=&amp;quot;https://&amp;lt;k3s-master-pi&amp;gt;:6443&amp;quot; K3S_TOKEN=&amp;quot;&amp;lt;k3s-token&amp;gt;&amp;quot; sh - After the agent installed and running, check the Pi was added to kubernetes cluster:
pi@pi-1:~ $ sudo kubectl get node -o wide NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME pi-1 Ready master 30d v1.17.0+k3s.1 192.168.10.16 &amp;lt;none&amp;gt; Raspbian GNU/Linux 10 (buster) 4.19.75-v7l+ containerd://1.3.0-k3s.5 pi-2 Ready &amp;lt;none&amp;gt; 47h v1.17.0+k3s.1 192.168.10.14 &amp;lt;none&amp;gt; Raspbian GNU/Linux 10 (buster) 4.19.75-v7l+ containerd://1.3.0-k3s.5 pi-3 Ready &amp;lt;none&amp;gt; 47h v1.17.0+k3s.1 192.168.10.15 &amp;lt;none&amp;gt; Raspbian GNU/Linux 10 (buster) 4.19.75-v7l+ containerd://1.3.0-k3s.5 pi-4 Ready &amp;lt;none&amp;gt; 10h v1.17.0+k3s.1 192.168.10.18 &amp;lt;none&amp;gt; Ubuntu 19.10 5.3.0-1014-raspi2 containerd://1.3.0-k3s.5 That is for today. The next steps are to figure out how to build Aerospike on arm64, but this is a story for another day.
Update (2020-01-15) I&amp;rsquo;ve managed to build and run Aerospike server for arm64! See make-arm64v8 branch in my fork of aerospike-server and the gist with my systemd services and configs.
Update (2020-02-13) A week ago I tried to install Ubuntu Server 18.04.3 on Pi 4 and didn&amp;rsquo;t even get to the login shell in the headless mode. Now Ubuntu Server 18.04.4 LTS is out and it works exactly as described in this note:
$ kubectl get node -o wide ⋯ NAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIME pi-1 Ready master 63d v1.17.2+k3s1 192.168.10.16 &amp;lt;none&amp;gt; Raspbian GNU/Linux 10 (buster) 4.19.93-v7l+ containerd://1.3.3-k3s1 pi-2 Ready &amp;lt;none&amp;gt; 35d v1.17.2+k3s1 192.168.10.14 &amp;lt;none&amp;gt; Raspbian GNU/Linux 10 (buster) 4.19.93-v7l+ containerd://1.3.3-k3s1 pi-3 Ready &amp;lt;none&amp;gt; 14m v1.17.2+k3s1 192.168.10.20 &amp;lt;none&amp;gt; Ubuntu 18.04.4 LTS 5.3.0-1017-raspi2 containerd://1.3.3-k3s1 pi-4 Ready &amp;lt;none&amp;gt; 4d23h v1.17.2+k3s1 192.168.10.19 &amp;lt;none&amp;gt; Ubuntu 19.10 5.3.0-1017-raspi2 containerd://1.3.3-k3s1</description></item><item><title>The Fireside Edition</title><link>https://vladimir.varank.in/notes/2019/12/the-fireside-edition/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/12/the-fireside-edition/</guid><description>After listening to the &amp;ldquo;Fireside edition&amp;rdquo; of Go Time FM, I questioned myself, how would I answered the questions the hosts discussed.
Because no one has asked, you are very welcome:
1. If you had two weeks to spend on a personal Go project, what would you work on? I really want to invest more time for profefe. Specifically, on implementing an analyser of stored profiles: the thing that would help to make sense of the data, showing how the performance of an instance, a node, or a cluster had changed over the period of time; how different parts of the codebase had influenced the performance of the application.
Recently Amazon has announced CodeGuru profiler (currently Java-only). From the description it feels exactly what I pictured in my head when I started the project.
Another topic that I would like to invest more time on is the understanding of the ecosystem around/inside Kubernetes. During the past two years, I slowed down the consumption of the DevOps/SRE topics, mostly due to the specific state of the infrastructure in our company. But, &amp;ldquo;k8s is the new linux&amp;quot;, regardless of what one&amp;rsquo;s opinion on that. Even profefe recently has ended up having a kube-profefe (a bridge between profefe and Kubernetes), contributed and maintained by other people.
2. What annoys you about Go of 2019? The same small things that annoyed me in Go 1.4: var, new, make and &amp;ldquo;naked return&amp;rdquo;. Sure, I understand that they all ended up in the language for a reason. But I simply don&amp;rsquo;t like the &amp;ldquo;magic&amp;rdquo; of make, which works only with particular types; the two ways of defining a variable (var or :=), or a pointer to an instance of a type (new or &amp;amp;T{}).
One new thing, though. Go modules&amp;rsquo; semver imports. But I can&amp;rsquo;t say anything new about that. Probably, I just need to embrase them. Go 1.14 looks like a version where I might completely switch to modules, thanks to better handling of vendored dependencies.
3. What&amp;rsquo;s your ideal working environment? That always surprises me. Lots of people keep saying that working from home is their ideal environment or even a factor that influence their job offers choice. I don&amp;rsquo;t like to work at home. The only time when I feel productive when stay home is in the nights. A cafe or a co-working works sometimes. But I like working in a big office space. I don&amp;rsquo;t know why.
Of course, open-plan offices can be very different. Yandex&amp;rsquo;s &amp;ldquo;Red Rose&amp;rdquo; is still the best space I ever worked in. I heard they do excursions around the Moscow&amp;rsquo;s office now.
3.1. Something on pair-programming? Since I wrote about Yandex.
Some people thing pair-programming is a sort of a super-power. It&amp;rsquo;s, and it&amp;rsquo;s not. You can&amp;rsquo;t just put yourself in an environment, where someone is watching how you write the code while trying to hold a conversation about the code architecture. Pair-programming is a skill to master. But it pays off.
The pair-(trio actually)-programming sessions we did in Yandex, when we worked on bem-core, was the most significant skill boost I had during the five+ years their.
Of course, the positive experience comes from your peers. In my case, they were people with a huge baggage of knowledge and practice of working, talking, debating with each other. Like, out of nowhere, you get the understanding of what types of questions you must ask; when it is important to spend more time on thinking and when you can make a small hack.
4. Your advice to you junior-developer self? Don&amp;rsquo;t overthink and afraid of starting anything. Trying something by making a raw, dirty, barely-working prototype will give you way more knowledge than thinking about how to do that.</description></item><item><title>[]byte to string conversion</title><link>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</link><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</guid><description>Go has an old wiki page, titled &amp;ldquo;Compiler And Runtime Optimizations&amp;quot;.
The part I like most there is different cases where compiler doesn&amp;rsquo;t allocate memory for string to []byte conversions:
For a map m of type map[string]T and []byte b, m[string(b)] doesn&amp;rsquo;t allocate (the temporary string copy of the byte slice isn&amp;rsquo;t made)
Turned out, since this wiki page was written, more similar optimisations were added to the compiler.
As it&amp;rsquo;s in Go 1.12+ the following cases are also listed in runtime/string.go:
Strings comcatenation For the case &amp;quot;&amp;lt;&amp;quot; + string(b) + &amp;quot;&amp;gt;&amp;quot;, where b is []byte no extra copying of b is needed.
Comparison if string(b) == &amp;quot;foo&amp;quot; { ··· } In the code above, b []byte also won&amp;rsquo;t be copied.
There are still cases where compiler can&amp;rsquo;t optimise the code for us. In some of those cases it&amp;rsquo;s fine to do string to bytes conversion using a so called &amp;ldquo;unsafe trick&amp;rdquo; (accessing string&amp;rsquo;s underling data directly, with out copying the data from string to bytes and vice versa). One can find several ways of performing the trick, but none of them seems &amp;ldquo;the one that must be used&amp;rdquo;.
After years of episodic discussions, a collegue of mine assembled the list of different conserns and about the proper way of doing it (see &amp;ldquo;unsafe conversion between string &amp;lt;-&amp;gt; []byte&amp;rdquo; topic on golang-nuts forum). Thanks to replies from Go team, our most valid way of doing it is following:
// Refer to github.com/fmstephe/unsafeutil type stringHeader struct { data unsafe.Pointer stringLen int } type sliceHeader struct { data unsafe.Pointer sliceLen int sliceCap int } func StringToBytes(s string) (b []byte) { stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) sliceHeader.data = stringHeader.data sliceHeader.sliceLen = len(s) sliceHeader.sliceCap = len(s) return b } func BytesToString(b []byte) (s string) { sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) stringHeader.data = sliceHeader.data stringHeader.stringLen = len(b) return s }</description></item><item><title>Github Actions and GOPATH</title><link>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</guid><description>The other day I received my beta access to GitHub Actions. To try them out I picked an existing pet project and created a workflow using a Go project template provided by GitHub. As it&amp;rsquo;s in September 2019, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.
My project is a classic Go service ;) meaning: it uses vendoring and doesn&amp;rsquo;t use Go modules. So no need for &amp;ldquo;get dependencies&amp;rdquo; step. And it requires to be inside the GOPATH. With that, the provided workflow needed some adjustment.
After some trials and errors, I&amp;rsquo;ve managed to make checkout step to clone the repo into the correct destination inside the GOPATH. Here is the final workflow:
name: Run Go test on: [pull_request] jobs: test: strategy: matrix: go-version: [1.12.9] runs-on: ubuntu-latest steps: - uses: actions/setup-go@v1 with: go-version: ${{ matrix.go-version }} - uses: actions/checkout@v1 with: path: ./src/github.com/${{ github.repository }} fetch-depth: 5 - run: make test env: GOPATH: ${{ runner.workspace }} Note, how actions/checkout@v1 above uses custom path input parameter. I set the path to ./src/github.com/${{ github.repository }}, so the project is checked out to src directory in the runners&amp;rsquo;s workspace, which I later pass as the value of GOPATH to the &amp;ldquo;make test&amp;rdquo; step. The leading dot in ./src seems very important — I&amp;rsquo;ve spent the majority of the time trying to figure out that part — refer to this issue.
See the workflow in action.
To learn more about those ${{ ··· }} &amp;ldquo;macroses&amp;rdquo; I suggest looking at the Actions&amp;rsquo; &amp;ldquo;Contexts and expression syntax&amp;rdquo; documentation.</description></item><item><title>Go's net/http.Headers</title><link>https://vladimir.varank.in/notes/2019/09/go-http-headers/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/go-http-headers/</guid><description>One probably knows that net/http.Headers is no more than map[string][]string with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:
type Header map[string][]string func (h Header) Add(key, val string) { if val == &amp;#34;&amp;#34; { return } h[key] = append(h[key], val) } func main() { h := make(Header) h.Add(&amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;b.example.com&amp;#34;) } From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&amp;rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&amp;rsquo;d like to avoid.
I was curious to know if Go&amp;rsquo;s standard library cares about that.
Looking at the implementation of net/textproto.Reader.ReadMIMEHeader(), which&amp;rsquo;s used in the standard HTTP server, or Go 1.13’s new net/http.Header.Copy(), it turned out they solve the problem quit elegantly.
We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.
Knowing that, we can refactor the initial Header.Add as the following:
type Header map[string][]string func (h Header) add(vv []string, key, val string) []string { if val == &amp;#34;&amp;#34; { ··· } // fast path for KV pair of a single value if h[key] == nil { vv = append(vv, value) h[key] = vv[:1:1] return vv[1:] } // slow path, when KV pair has two or more values h[key] = append(h[key], val) return vv } func main() { h := make(Header) // net/textprotocol pre-counts total number of request&amp;#39;s headers // to allocate the slice of known capacity vv := make([]string, 0) vv = h.add(vv, &amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) vv = h.add(vv, &amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) } Note that we use vv[:1:1] to create a subslice of the fixed capacity (length 1, capacity 1).
If there is a KV-pair that has several values, e.g. &amp;ldquo;Via&amp;rdquo; header, Add will allocate a separate slice for that key, doubling its capacity.</description></item><item><title>Hello World</title><link>https://vladimir.varank.in/notes/2019/09/hello-world/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/hello-world/</guid><description>Let&amp;rsquo;s create a blog. But let&amp;rsquo;s call them &amp;ldquo;notes&amp;rdquo;.
Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</description></item></channel></rss>