<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/</link><description>Recent content in Notes on Vladimir Varankin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 17 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>A real life use-case for generics in Go: API for client-side pagination</title><link>https://vladimir.varank.in/notes/2022/05/a-real-life-use-case-for-generics-in-go-api-for-client-side-pagination/</link><pubDate>Tue, 17 May 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/05/a-real-life-use-case-for-generics-in-go-api-for-client-side-pagination/</guid><description>&lt;p>Let&amp;rsquo;s say we have a RESTful API for a general ledger, with the endpoints, that return a paginated collection of resources:&lt;/p>
&lt;ol>
&lt;li>&lt;code>GET /accounts&lt;/code>, retrieves a list of accounts, filtered and sorted by some query parameters;&lt;/li>
&lt;li>&lt;code>GET /accounts/:uuid/transactions&lt;/code>, retrieves a list of transactions for account;&lt;/li>
&lt;li>&lt;code>GET /postings&lt;/code>, retrieves a list of &lt;a href="https://en.wikipedia.org/wiki/Double-entry_bookkeeping">postings&lt;/a> stored in the ledger.&lt;/li>
&lt;/ol></description></item><item><title>Bookmarks (issue 2)</title><link>https://vladimir.varank.in/notes/2022/04/bookmarks-2/</link><pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/04/bookmarks-2/</guid><description>Digital object identifier (DOI) (Wikipedia). A DOI is a persistent identifier or handle used to identify various objects uniquely. It aims to be &amp;ldquo;resolvable&amp;rdquo;, usually to some form of access to the information object to which the DOI refers. This is achieved by binding the DOI to metadata about the object, such as a URL. Thus, by being actionable and interoperable, a DOI differs from identifiers such as ISBNs, which aim only to identify their referents uniquely.
Operations principles: securely deploying the graph to production at scale (Principled GraphQL). Lots of things listed there apply to any sort of APIs — not only to GraphQL.
Songs your English teacher will NEVER teach! (Learn English with Papa Teach Me). Vocabulary from &amp;ldquo;Savage&amp;rdquo;, &amp;ldquo;WAP&amp;rdquo;, and &amp;ldquo;34+35&amp;rdquo;. This video is definitely not for kids!
8 phrases to spring-clean from your emails (Grammarly).
Platforms and Power (Acquired). &amp;ldquo;7 Powers&amp;rdquo; author Hamilton Helmer and Chenyi Shi (Strategy Capital), joined Acquired Podcast to discuss platform businesses, and how the &amp;ldquo;Power&amp;rdquo; framework applies to them.
Halfthings (Mat Ryer). Building something for the users to play with, to touch, to feel, to break, makes all the difference and moves the conversations away from the meta. Doing &amp;ldquo;one thing&amp;rdquo; or &amp;ldquo;building an MVP&amp;rdquo; can easily pull you into a &amp;ldquo;too much&amp;rdquo; for a validation phase. Build a &amp;ldquo;halfthing&amp;rdquo; instead.</description></item><item><title>Bookmarks (issue 1)</title><link>https://vladimir.varank.in/notes/2022/03/bookmarks-1/</link><pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/03/bookmarks-1/</guid><description>Generics can make your Go code slower (PlanetScale):
boxing vs monomorphization vs partial monomorphization (&amp;ldquo;GCShape stenciling with Dictionaries&amp;rdquo;) interface inlining doesn&amp;rsquo;t work well with the 1.18&amp;rsquo;s compiler generics work well for byte sequences (string | []byte) in simple cases, generics can be useful for function callbacks. How Meta enables de-identified authentication at scale. The rational, the use-cases, and a high-level architecture of Meta&amp;rsquo;s Anonymous Credential Service (ACS).
Hidden dangers of duplicate key violations in PostgreSQL (AWS). INSERT … ON CONFLICT has additional benefits, if compared to relying on PostgreSQL&amp;rsquo;s &amp;ldquo;duplicate key violation&amp;rdquo; error:
no additional space needed for dead tuples less autovacuum required transaction IDs aren&amp;rsquo;t used for nothing, preventing (postponing) the potential trx-id wraparound. Diving into AWS IAM Roles for (Kubernetes) Service Accounts (IRSA).</description></item><item><title>Go talks I keep coming back to</title><link>https://vladimir.varank.in/notes/2022/02/go-talks-i-keep-coming-back-to/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/02/go-talks-i-keep-coming-back-to/</guid><description>I have a personal list of &amp;ldquo;top conference talks&amp;rdquo; that I keep referring back to, even after years of working with Go:
Go profiling from bottom up, Felix Geisendörfer, GoLab 2021. Felix explains what&amp;rsquo;s under the hood of Go&amp;rsquo;s pprof. Evolving the Go Memory Manager&amp;rsquo;s RAM and CPU Efficiency, Michael Knyszek, GopherCon 2020 Death by 3,000 Timers: Streaming Video-on-Demand for Cable TV, Chris Hines, GopherCon 2019. Chris explains the mechanics behind the Go runtime scheduler, following the anomaly cases, they observed, when ran a Go application on a physical machine, with large number of CPU cores. Rethinking Classical Concurrency Patterns (Slides), Bryan C. Mills, GopherCon 2018. Brian demos the implementation of typical concurrency patterns, following the famous Go proverb: &amp;ldquo;Don&amp;rsquo;t communicate by sharing memory; share memory by communicating.&amp;rdquo; GoLab Keynote, Bill Kennedy, GoLab 2018. Bill demoes the ways to reason about the performance of a Go application, with the help of Go runtime tracer. The Scheduler Saga, Kavya Joshi, GopherCon 2018. Kavya shows what stands behind the magic of Go runtime. Restarting Go applications gracefully (in Russian), Сергей Камардин, GopherCon Russia 2018 Advanced Testing with Go, Mitchell Hashimoto, GopherCon 2017 Understanding Channels, Kavya Joshi, GopherCon 2017. Kavya explains how channels work under the hood. Keeping the list here, in public, should help my future self, in a situation where I&amp;rsquo;m stuck with a mind-blocker, and I need to quickly pull out a piece of community wisdom from the backyards of my memory. The list isn&amp;rsquo;t meant to be complete, and I expect to add more links here, moving forward.
Did I miss any? Share your suggestions with me on Twitter.</description></item><item><title>Love. Hate. Material Design</title><link>https://vladimir.varank.in/notes/2022/02/love-hate-material/</link><pubDate>Wed, 02 Feb 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/02/love-hate-material/</guid><description>&lt;p>If Chrome had a notch&lt;/p>
&lt;figure>&lt;img src="https://vladimir.varank.in/images/2022/material-chrome-cut-1x.jpg"
alt="Chrome notch" width="1000"/>
&lt;/figure></description></item><item><title>I've got COVID. What do I do next?</title><link>https://vladimir.varank.in/notes/2022/01/i-got-covid/</link><pubDate>Mon, 31 Jan 2022 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2022/01/i-got-covid/</guid><description>&lt;p>Go to &lt;a href="https://www.berlin.de/corona/massnahmen/abstands-und-hygieneregeln/">https://www.berlin.de/corona/massnahmen/abstands-und-hygieneregeln/&lt;/a> for the information (in German) about the latest regulations in Berlin. For the up-to-date information in your region, consult with your local authorities.&lt;/p>
&lt;p>&lt;em>Everything I list below are the steps I found relevant, after I&amp;rsquo;ve self-tested positive for COVID in Berlin, in the end of January 2022&lt;/em>.&lt;/p>
&lt;h3 id="friday-28th-january-2022">Friday, 28th January 2022&lt;/h3>
&lt;p>I woke up with some &lt;em>mild&lt;/em> symptoms of cold. On the day before I worked from home, and only had a usual an hour-long walk around Prenzlauer Berg — Mitte after the workday. The rapid antigen test (&lt;em>Schnelltest&lt;/em>) was negative.&lt;/p>
&lt;p>While still working from home, I took a &amp;ldquo;quiet Friday&amp;rdquo; at work, to simply focused on some mundane routines.&lt;/p>
&lt;p>I went for a short walk in the afternoon, bought some grocery, and headed home.&lt;/p>
&lt;h3 id="saturday-29th-january">Saturday, 29th January&lt;/h3>
&lt;p>Didn&amp;rsquo;t feel anywhere better or worse: mostly had a runny nose and a dry throat. I didn&amp;rsquo;t want to wait in the line for a quick-test, so I&amp;rsquo;ve just walked around the city for an hour and went home.&lt;/p>
&lt;h3 id="sunday-30th-january">Sunday, 30th January&lt;/h3>
&lt;p>It felt the same as it&amp;rsquo;d been the day before, although the dry throat started to feel a bit more intense. Walked around for an hour, came home, made some coffee ;)&lt;/p>
&lt;p>A couple hours later I started to cough. I made a self-test — we still had some at home — and,&lt;/p>
&lt;blockquote>
&lt;p>&lt;em>Here we are! Welcome to the &amp;ldquo;two-stripes&amp;rdquo; club&lt;/em>.&lt;/p>
&lt;/blockquote></description></item><item><title>Error messages in Go</title><link>https://vladimir.varank.in/notes/2021/12/error-messages-in-go/</link><pubDate>Thu, 30 Dec 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/12/error-messages-in-go/</guid><description>When Go code propagates an error, the following pattern is very popular:
fmt.Errorf(&amp;#34;failed to find a parking slot: %w&amp;#34;, err) // Or fmt.Errorf(&amp;#34;could not call mom: %w&amp;#34;, err) These &amp;ldquo;could not&amp;rdquo;, &amp;ldquo;failed to&amp;rdquo;, &amp;ldquo;unable to&amp;rdquo; make sense when my mind is in the local context of the function, method or package. But, in most of the cases I have to deal with, it makes the resulting log message overloaded with informational garbage:
unable to ask about the cat: failed to call mom: failed to do request: Get https://: context canceled While discussing this issue with a colleague, we came up with the following &amp;ldquo;better&amp;rdquo; strategy:
only the logger should express its attitude to the facts, using words &amp;ldquo;error&amp;rdquo;, &amp;ldquo;failed&amp;rdquo;, etc the business code must operate only with facts, e.g. &amp;ldquo;call mom&amp;rdquo;. err := CallMom(number) if err != nil { return fmt.Errorf(&amp;#34;call mom (tel %s): %w&amp;#34;, number, err) } This renders as following to the application logs:
error: ask about cat: call mom (tel 123): make request: Get https://: context canceled For a long stack of errors, this makes the full error message more dense, showing more useful information per line.</description></item><item><title>Good coffee places in Berlin</title><link>https://vladimir.varank.in/notes/2021/10/good-coffee-places-in-berlin/</link><pubDate>Sun, 10 Oct 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/10/good-coffee-places-in-berlin/</guid><description>&lt;p>My definition of &amp;ldquo;good coffee places&amp;rdquo; includes, although, by no mean limited by, offering a &amp;ldquo;not too fruity&amp;rdquo; (sometimes &amp;ldquo;chocolaty&amp;rdquo;) Filter coffee or a decent Americano.&lt;/p></description></item><item><title>Making sense of requests for CPU resources in Kubernetes</title><link>https://vladimir.varank.in/notes/2021/09/making-sense-of-requests-for-cpu-resources-in-kubernetes/</link><pubDate>Sun, 26 Sep 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/09/making-sense-of-requests-for-cpu-resources-in-kubernetes/</guid><description>Kubernetes allows a container to request several resource types:
apiVersion: v1 kind: Pod metadata: name: my-app spec: containers: - name: my-app image: images.example/my-app resources: requests: cpu: &amp;#34;100m&amp;#34; memory: &amp;#34;64Mi&amp;#34; limits: cpu: &amp;#34;500m&amp;#34; memory: &amp;#34;128Mi&amp;#34; One particularly confusing type of the resource for me was cpu. For example, in the manifest above, the my-app container declares a request for &amp;ldquo;100m&amp;rdquo; of the CPU. What does that mean?
Kubernetes&amp;rsquo;s documentation on managing containers resources describes that as following:
Limits and requests for CPU resources are measured in cpu units. One cpu, in Kubernetes, is equivalent to 1 vCPU/Core for cloud providers and 1 hyperthread on bare-metal Intel processors. CPU is always requested as an absolute quantity, never as a relative quantity; 0.1 is the same amount of CPU on a single-core, dual-core, or 48-core machine.
A misleading (but fairly common) mental modal amongst the developers, is that the application inside the Pod&amp;rsquo;s container is &amp;ldquo;boxed&amp;rdquo; by the container runtime, as if the application received a dedicated slice of the machine&amp;rsquo;s resources. That&amp;rsquo;s not exactly how it works. At least, it&amp;rsquo;s not if Kubernetes uses Docker as the underlying container runtime.
I find it easier to think about the requested resources as a way for an application to &amp;ldquo;hint&amp;rdquo; to Kubernetes scheduler about how much resources the application thinks it needs.
Kubernetes scheduler keeps the &amp;ldquo;accounting&amp;rdquo; for how much of total resources the tenants of the cluster requested, and how much the cluster&amp;rsquo;s machines have to offer. It&amp;rsquo;s important to stress that the &amp;ldquo;accounting&amp;rdquo; is done only base on the requests for the resources. That is, the scheduler doesn&amp;rsquo;t check if the container uses the resources it requested. If a container requested more than half of the node&amp;rsquo;s CPU resources, e.g. &amp;ldquo;1100m&amp;rdquo; on a 2 vCPU node, Kubernetes won&amp;rsquo;t deploy more than a single replica of this container to that node, nomatter if the application inside the container is idle.
Each node has a maximum capacity for each of the resource types: the amount of CPU and memory it can provide for Pods. The scheduler ensures that, for each resource type, the sum of the resource requests of the scheduled containers is less than the capacity of the node. Note that although actual memory or CPU resource usage on nodes is very low, the scheduler still refuses to place a Pod on a node if the capacity check fails.
What has been requested, has been booked.
Of course, &amp;ldquo;accounting&amp;rdquo; of the existing resources is only half of the story. In the same documentation about managing containers resources, they talk about the implementation details of what happens after a container gets scheduled to a node, refering to Docker&amp;rsquo;s documentation about CPU share constraint. This details for how Docker itself juggles the CPU shares between the running containers can be even more confusing but the interesting part to remember is the following:
The proportion [of CPU cycles] will only apply when CPU-intensive processes are running. When tasks in one container are idle, other containers can use the left-over CPU time. [..] On a multi-core system, the shares of CPU time are distributed over all CPU cores. Even if a container is limited to less than 100% of CPU time, it can use 100% of each individual CPU core.
The important difference between the ideas of a &amp;ldquo;box&amp;rdquo; and a &amp;ldquo;hint&amp;rdquo; is that the &amp;ldquo;hint&amp;rdquo; doesn&amp;rsquo;t prevent the application from consuming the whole node&amp;rsquo;s CPU resources, when it requested only half of it — containers are not the VMs, afterall. Using the same example of a cluster&amp;rsquo;s node with 2 vCPU, a multi-threaded application inside a container still sees two CPU cores. If there are no other tenants on the node, there is no one who the application has to compete for its share of CPU resources.
As mentioned earlier, this applies to Docker container runtime. Don&amp;rsquo;t forget to consult with the documentation provided by the particular Kubernetes distribution when you make the decisions, that includes the fine-tunning of cluster resources. Docker is still the runtime AWS EKS uses for Kubernetes up to version 1.21. But things might work differently for your cluster as Kubernetes providers switch to alternative container runtimes.
Let&amp;rsquo;s discuss this note on Hacker News and Twitter.</description></item><item><title>One step closer to "Tabless" workflow</title><link>https://vladimir.varank.in/notes/2021/08/one-step-closer-to-tabless-workflow/</link><pubDate>Mon, 23 Aug 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/08/one-step-closer-to-tabless-workflow/</guid><description>Many years ago I embraced &amp;ldquo;tabless&amp;rdquo; development workflow: I use buffers, when I&amp;rsquo;m in Vim; I also switch tabs off in both Goland and VS Code, as the first thing after I install the IDEs to a new laptop.
I&amp;rsquo;m trying the same with Firefox web-browser now:
Enable toolkit.legacyUserProfileCustomizations.stylesheets switch in Firefox&amp;rsquo;s config (via about:config page or inside user.js).
Place the styles below into %PROFILE%/chrome/userChrome.css (I pick the actual path to the profile directory from Firefox&amp;rsquo;s about:support page).
// Hide the tabs. // Beware that hidding the tabs with &amp;#34;display: none&amp;#34; will ruine you browser&amp;#39;s recent history, // I&amp;#39;ve learned that in a hard way ;) #TabsToolbar &amp;gt; .toolbar-items { opacity: 0; pointer-events: none; } // Pull the navigation bar up, on top of the empty space, that left after we&amp;#39;d hidden the tabs. #nav-bar { margin-top: calc((7px + var(--tab-min-height)) * -1); } // On macOS, when not in full screen, shift the urlbar&amp;#39;s panel to the right, // after close-minimise-expand buttons. :root:not([inFullscreen]) #nav-bar-customization-target { margin-left: 65px; } I looked at mozilla-central/··/navigator-toolbox.inc.xhtml to get the structure of Firefox&amp;rsquo;s UI.
Pick some nice and clean theme. My kudos to Safari - MacOS Monterey Light by a person nicknamed notcat.
(Optional) In Firefox&amp;rsquo;s &amp;ldquo;General&amp;rdquo; preferences, switch off &amp;ldquo;Ctrl+Tab circles through tabs&amp;rdquo;. With that, pressing Ctrl+Tab exposes all currently open pages (similar to how on macOS or other OS one switches between the opened applications with ⌘+Tab).
Overall I&amp;rsquo;m fairly happy with how it ended up. Although, some things aren&amp;rsquo;t quite ideal yet (might add more as I use this setup):
I wish there was a shortkey to enter a &amp;ldquo;modal mode&amp;rdquo;, where I could filter the list of open pages, to search for a particular page, and to switch to this page. Something similar to :ls command in Vim, or ⌘+E in Goland. I can use Firefox&amp;rsquo;s &amp;ldquo;Search amongst Tabs&amp;rdquo; for that (press ⌘+L to focus into the URL bar, and querying with &amp;ldquo;%[space]&amp;rdquo;) but that requires some getting used to.
Firefox has &amp;ldquo;Show all tabs&amp;rdquo; button (Ctrl+Shift+Tab) but the way it works, at least in Firefox 91, is very confusing and random. It seems to me, its behaviour is tightly coupled to the browser&amp;rsquo;s Tab UI.</description></item><item><title>Self-signed certificates with k3s and cert-manager</title><link>https://vladimir.varank.in/notes/2021/07/self-signed-certificates-with-k3s-and-cert-manager/</link><pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/07/self-signed-certificates-with-k3s-and-cert-manager/</guid><description>At least for now, my homelab cluster (4x Raspberry Pi, k3s, etc) is available only for the devices on my local network, inside a custom DNS zone k8s.pi.home. I don&amp;rsquo;t think there are practical reasons to run anything with HTTPS in that setup, but there are cases, like browser extensions, where it&amp;rsquo;s required.
Turned out, in 2021, it&amp;rsquo;s fairly straight forward to set up a Certificate Authority (CA), that will issue TLS certificates to &amp;ldquo;secure&amp;rdquo; the ingress resources. At least, it&amp;rsquo;s way simpler comparing to how I remember it was back in the days. All thanks to cert-manager and some YAML.
First thing is to install cert-manager to the cluster. k3s comes with helm-controller, that gives us a way to manage helm charts with Custom Resource Definitions (CRD). The following manifest defines a new namespace, and a resource of a kind HelmChart, to install cert-manager inside this namespace:
apiVersion: v1 kind: Namespace metadata: name: cert-manager --- apiVersion: helm.cattle.io/v1 kind: HelmChart metadata: name: cert-manager namespace: kube-system spec: chart: cert-manager repo: https://charts.jetstack.io targetNamespace: cert-manager valuesContent: |- installCRDs: true prometheus: enabled: true servicemonitor: enabled: true After applying the manifest above — kubectl apply -f cert-manager.yml — define a self-signed certificate, which is used to bootstrap a CA:
apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: selfsigned-cluster-issuer spec: selfSigned: {} --- apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: selfsigned-ca spec: isCA: true commonName: selfsigned-ca secretName: selfsigned-ca-root-secret privateKey: algorithm: ECDSA size: 256 issuerRef: name: selfsigned-cluster-issuer kind: ClusterIssuer group: cert-manager.io --- apiVersion: cert-manager.io/v1 kind: Issuer metadata: name: selfsigned-issuer spec: ca: secretName: selfsigned-ca-root-secret And now, I can use selfsigned-issuer to issue TLS certificates for the ingress resources (Traefik ingress in the k3s&amp;rsquo;s case). E.g. to play around, I run an open-source version of LanguageTool server. The ingress manifests for the server looks like as following:
apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: languagetool-server annotations: kubernetes.io/ingress.class: traefik cert-manager.io/issuer: selfsigned-issuer spec: rules: - host: languagetool.k8s.pi.home http: paths: - path: / pathType: ImplementationSpecific backend: service: name: languagetool-server port: number: 8010 tls: - hosts: [languagetool.k8s.pi.home] secretName: languagetool-server-cert Of course, any certificate signed by my CA won&amp;rsquo;t be automatically trusted by anyone, including my own system. If I try to access https://languagetool.k8s.pi.home, any HTTP client will raise a &amp;ldquo;failed to verify the legitimacy of the server&amp;rdquo; issue. I don&amp;rsquo;t know if there is a better way to solve that, but I can hack that around by installing the cluster&amp;rsquo;s root CA certificate into the system&amp;rsquo;s keychain, and telling the system, that it should &amp;ldquo;trust&amp;rdquo; the certificate:
$ kubectl get secret/selfsigned-ca-root-secret -o json \ | jq -r &amp;#39;.data[&amp;#34;ca.crt&amp;#34;]&amp;#39; \ | base64 -D &amp;gt; ~/tmp/selfsigned-root-ca.crt $ open ~/tmp/selfsigned-root-ca.crt Choose &amp;ldquo;Always trust&amp;rdquo; the certificate in the keychain&amp;rsquo;s certificate settings. The server looks legitimate now!</description></item><item><title>Wireless-to-Ethernet island for homelab cluster: IPv6, NDP proxy and mDNS reflector</title><link>https://vladimir.varank.in/notes/2021/04/wireless-to-ethernet-island-for-homelab-cluster-ipv6-ndp-proxy-and-mdns-reflector/</link><pubDate>Mon, 26 Apr 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/04/wireless-to-ethernet-island-for-homelab-cluster-ipv6-ndp-proxy-and-mdns-reflector/</guid><description>&lt;p>Initially, when I assembled &lt;a href="https://vladimir.varank.in/notes/2020/01/raspi-ubuntu-arm64-k3s/">a homelab cluster of Raspberry Pis&lt;/a>, everything was directly connected to my Wi-Fi router with the Ethernet cables. This worked fine but this &amp;ldquo;stack of boards&amp;rdquo; behind the sofa in the centre of our small flat bugged me a bit.&lt;/p>
&lt;p>Last year I decided to reorganise the cluster, turning it into a &lt;em>wireless-to-wired island&lt;/em>, which I could relocate anywhere within the flat, without doing any special cable management, while staying cheap and avoid stacking the appartment with even more gadgets. After going through a number of trials and errors, the final setup looks as the following:&lt;/p>
&lt;figure>&lt;img src="https://vladimir.varank.in/images/2021/homelab-pi-net-1.png"
alt="Homelab cluster as a wireless-to-ethernet island (2021)" width="820"/>
&lt;/figure>
&lt;p>Different colours contour the connections between two logical subnets — more on that later. Here what we have on the schema (top to bottom):&lt;/p></description></item><item><title>Development environment in 2020</title><link>https://vladimir.varank.in/notes/2021/04/development-environment-in-2020/</link><pubDate>Mon, 05 Apr 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/04/development-environment-in-2020/</guid><description>Last year I made this one, after involving myself into a very random discussion on Twitter, about the unnecessary complexity and none-sense of modern days&amp;rsquo; development environments.</description></item><item><title>Little things of Go HTTP handlers</title><link>https://vladimir.varank.in/notes/2021/03/little-things-of-go-http-handlers/</link><pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/03/little-things-of-go-http-handlers/</guid><description>Every time I sketch an HTTP API in Go, I wrap the code of request handlers around these small but very convenient bits.
My handlers are methods or functions, that serve a request and, either write a (positive) response or return an error.
// HandlerFunc is an HTTP handler function, that handles an HTTP request. // It writes the response to http.ResponseWriter or returns an error. type HandlerFunc func(w http.ResponseWriter, r *http.Request) error // Handler is an adaptor for HandlerFunc, that converts the handler into http.Handler. // It makes sure all errors returned from h are handled in a consistent manner. func Handler(h HandlerFunc) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { err := h(w, r) if err != nil { handleError(w, r, err) } }) } An error returned from HandlerFunc can be an indicator of a failure in request processing, statusError, or a general &amp;ldquo;something didn&amp;rsquo;t work&amp;rdquo;-error. The later can contain the internal details, that the API must never expose to the user.
// StatusError wraps an error err and contains the suggestion regarding to // how the error should be communicated to the user. // // code must be a valid HTTP status code; text is the message to reply to user. func StatusError(code int, text string, err error) error { return &amp;amp;statusError{ Code: code, Text: text, Err: err, } } type statusError struct { Code int Text string Err error } func (s statusError) Error() string { return s.Text } func (s statusError) Unwrap() error { return s.Err } handleError is a helper function, which makes sure all errors returned from HandlerFunc are handled and replied to the user consistently. The internal details — the cause of the error — aren&amp;rsquo;t exposed to the user, but the helper can provide a unified logging and metrics, which would be convenient when debugging the error later:
var ErrNotFound = StatusError(http.StatusNotFound, &amp;#34;Nothing found&amp;#34;, nil) func handleError(w http.ResponseWriter, r *http.Request, err error) { var statusErr *statusError if !errors.As(err, &amp;amp;statusErr) { statusErr = &amp;amp;statusError{Code: http.StatusInternalServerError, Text: &amp;#34;Internal server error&amp;#34;, Err: err} } rid := RequestIDFromContext(r.Context()) resp := errResponse{ RequestID: rid, Error: statusErr.Text, } replyJSON(w, resp, statusErr.Code) // underlying error can be nil, as a special case, when the error is a client-side problem if err := errors.Unwrap(statusErr); err != nil { log.Errorw(&amp;#34;request failed&amp;#34;, &amp;#34;request-id&amp;#34;, rid, &amp;#34;uri&amp;#34;, r.RequestURI, &amp;#34;error&amp;#34;, err) } } replyJSON is a helper function, which writes a JSON string to http.ResponseWriter, setting the proper HTTP headers.
func replyJSON(w http.ResponseWriter, v interface{}, code int) { w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json&amp;#34;) w.WriteHeader(code) err := json.NewEncoder(w).Encode(v) if err != nil { io.WriteString(w, `{&amp;#34;code&amp;#34;:500,&amp;#34;error&amp;#34;:`+strconv.Quote(err.Error())+`}`) } } How does it look in practice?
Below is an extract from a hypothetical API, with one single route /api/login, that takes an email, and replies with JSON, that contains this account&amp;rsquo;s ID.
func setupRoutes(mux *http.ServeMux) { authHandler := NewAuthHandler(···) mux.Handle(&amp;#34;/api/login&amp;#34;, Handler(authHandler.HandleLogin)) } type AuthHandler { // internal dependencies } func (h *AuthHandler) HandleLogin(w http.ResponseWriter, r *http.Request) error { ctx := r.Context() req, err := DecodeLoginRequest(r) if err != nil { return fmt.Errorf(&amp;#34;decode login request: %w&amp;#34;, err) } if req.Email == &amp;#34;&amp;#34; { return StatusError(http.StatusBadRequest, &amp;#34;email is required&amp;#34;, nil) } accID, err := h.datastore.GetAccountByEmail(ctx, req.Email) if errors.Is(err, ErrNotExists) { return StatusError(http.StatusForbidden, &amp;#34;account does not exist&amp;#34;, err) } if err != nil { return fmt.Errorf(&amp;#34;get account for %q: %w&amp;#34;, req.Email, err) } resp := struct { ID string `json:&amp;#34;id&amp;#34;` }{ ID: accID, } // ReplyJSON is a wrapper around internal replyJSON, that always responses with http.StatusOK ReplyJSON(w, resp) return nil } Do you have your own little things, that help you to lay out the boilerplate? Discuss this note on Twitter or Reddit.</description></item><item><title>(You don't) Insert unicode NULL character as Postgres jsonb</title><link>https://vladimir.varank.in/notes/2021/01/you-dont-insert-unicode-null-character-as-postgres-jsonb/</link><pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2021/01/you-dont-insert-unicode-null-character-as-postgres-jsonb/</guid><description>With JSON data type it’s easy to treat Postgres as a document database, which doesn’t need strong schema. One can define a table, that has a field of a type jsonb and insert any valid JSON string (a “document”).
I’ve learned lately, that Postgres’s jsonb prohibits insertion of a valid JSON string if the string contains NULL (U+0000) character. Postgres’s own docs on JSON Types says:
RFC 7159 permits JSON strings to contain Unicode escape sequences denoted by \uXXXX. In the input function for the json type, Unicode escapes are allowed regardless of the database encoding, and are checked only for syntactic correctness. However, the input function for jsonb is stricter: it disallows Unicode escapes for non-ASCII characters (those above U+007F) unless the database encoding is UTF8. The jsonb type also rejects \u0000 (because that cannot be represented in PostgreSQL&amp;rsquo;s text type), and it insists that any use of Unicode surrogate pairs to designate characters outside the Unicode Basic Multilingual Plane be correct.
In my case, a Go backend inserts tracing logs to Postgres. A trace consists of multiple “spans”, some of which can contain the reply from an external API. As we found out, sometimes, in the event of a failure, the API replies with an empty GIF &amp;lt;facepalm/&amp;gt;. Our backend converts the response to a string, marshals it to a JSON and later tries to insert the JSON into a Postgres table.
Consider the following Go code:
// data is an empty GIF var data = []byte{ 0x47, 0x49, 0x46, 0x38, 0x39, 0x61, 0x01, 0x00, 0x01, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x21, 0xf9, 0x04, 0x01, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x02, 0x01, 0x44, 0x00, 0x3b, } func main() { v, _ := json.Marshal(struct { Resp interface{} `json:&amp;#34;resp,omitempty&amp;#34;` }{ Resp: string(data), }) fmt.Printf(&amp;#34;%s\n&amp;#34;, v) // Output (truncated for readability): // {&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\u0000\ufffd\···\u0001D\u0000;&amp;#34;} } Above, json.Marshal produces a perfectly valid JSON. But if I try to insert it into a Postgres table as jsonb, the insert fails with “unsupported Unicode escape sequence”:
= CREATE TABLE logs (data jsonb); = INSERT INTO logs VALUES (&amp;#39;{&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\u0000\ufffd\···\u0001D\u0000;&amp;#34;}&amp;#39;); ERROR: unsupported Unicode escape sequence LINE 1: insert into logs values (&amp;#39;{&amp;#34;resp&amp;#34;:&amp;#34;GIF89a\u0001\u0000\u0001\... ^ DETAIL: \u0000 cannot be converted to text. CONTEXT: JSON data, line 1: {&amp;#34;resp&amp;#34;:... Because in my code, there were only a couple of places where I didn&amp;rsquo;t control the actual data, that went into a span, the way I’ve chosen to handle that was by introducing a wrapper type, that implements json.Marshaller. The wrapper checks the value is a valid UTF-8 sequence and doesn’t contain NULL character before it marshals the value into a JSON string. If the value is not a valid UTF-8, the marshaller sees it as a binary data and base64-encodes it.
// RawText handles invalid UTF-8 and NULL-bytes, encoding them as base64-string. // Because we have to make sure the resulting JSON will be compatible with Postgres&amp;#39;s jsonb, // we must use RawText when we don&amp;#39;t control the data, e.g. when log the error from an external API. // Refer to https://www.postgresql.org/docs/10/datatype-json.html type RawText []byte func (v RawText) MarshalEasyJSON(w *Writer) { if utf8.Valid(v) &amp;amp;&amp;amp; !bytes.ContainsRune(v, &amp;#39;\u0000&amp;#39;) { // &amp;#34;valid&amp;#34; text is marshalled as string w.String(string(v)) } else { // &amp;#34;invalid&amp;#34; text is marshalled as binary data w.Raw(json.Marshal([]byte(v))) } } Note, the code above is a marshaller for github.com/mailru/easyjson, which we use in the project.
Here is how it looks in practice:
func main() { v, _ := json.Marshal(struct { Resp1 interface{} `json:&amp;#34;resp1,omitempty&amp;#34;` Resp2 interface{} `json:&amp;#34;resp2,omitempty&amp;#34;` }{ Resp1: RawText(bin), // wrap the bin data into RawText Rest2: RawText(&amp;#34;normal string&amp;#34;), // wrap (copy) a string into RawText }) fmt.Printf(&amp;#34;%s\n&amp;#34;, v) // Output: // { // &amp;#34;resp1&amp;#34;:&amp;#34;R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;#34;, // &amp;#34;resp2&amp;#34;:&amp;#34;normal string&amp;#34; // } }</description></item><item><title>2020, what a year</title><link>https://vladimir.varank.in/notes/2020/12/2020-what-a-year/</link><pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/12/2020-what-a-year/</guid><description>2020 was (technically, still is) an extraordinary year. For many people, this was the worst, the weirdest, the most depressing year; the year we wish was a bad dream. With all the respect for the terrible things, lots of people went through, for me, it was a year to remember.
In 2020 I learned how to work from home. It’s still not super fun, but it’s possible. As I look at that now, there are obvious benefits: I can start and end my day much more freely; I currently don’t feel much pressure when willing to go for a walk or a run at 11:00, or when I finish my workday at 16:00 (I tend to start around 8:30 while at home). But that being said, I still don’t consider staying full-remote and I want to go back to the office, co-working, or a random coffee bar.
In 2020 I bought a bicycle. After three years in Berlin, I’m with “all of those people” now :) Can’t say I’m super excited about the purchase. Mostly because I live in the walking distance from the office. With the bicycle, my “commute” is only five or seven minutes shorter. I have to wait at the traffic lights a lot; plus I have to spend extra minutes to lock/unlock the bicycle.
In 2020 I walked, on average, one kilometre per day more, than in the previous year (5.5 km vs 4.2 km). A bit of surprise but, overall this year, I walked less than I did in 2019. I bet that’s because this year we, obviously, didn’t travel much, so we didn’t have a chance to spend weeks walking around a new city, neither in Spring, nor on Christmas and New Year.
In 2020 we adopted a cat. The CAT, who’s now called Gagarin! He came to us from the middle of “nowhere-Russia” as a frightened little kitten and spent the first month under our bed, avoiding walking under the light. And now, after four months, he comes to have a nap on our pillow (and on my head) at 7:00, as his way to signal that it’s time to feed him.
In 2020 I assembled my four nodes Raspberry Pi Kubernetes cluster, but I haven’t made much use of it yet. As promised to myself in December 2019, during the year I learned and touched some new Kubernetes details, and I have tons of things I still want to get my hands into to understand on a more in-depth level of details.
In 2020 I started to learn Rust. I tried learning it in 2018 and in 2019. But this year, I actually spent a month or two writing code, not only reading/watching/listening to/following the content. It feels refreshing. Programming for embedded devices and game-dev are the most attractive fields that I want to explore further with Rust.
In 2020 I had two job interviews. None of them were successful for me, although I tend to believe that I’ve passed both. I have plans to draft a note about the essential questions one must ask the HR during the first call, somewhere later.
In 2020 I did and learned, and read, and listened to, and watched, and thought about a bunch of things.
In 2021 I will do even better.</description></item><item><title>On code-reviews</title><link>https://vladimir.varank.in/notes/2020/12/on-code-reviews/</link><pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/12/on-code-reviews/</guid><description>This is another thought experiment, this time on the importance of my feedback in the code-reviews.
Providing you’re working on a project maintained by a set team of N people. What would happen with the codebase if, for six months, in code-reviews, you started to accept changes for which, you generally leave feedback?
&amp;ldquo;Variables, struct or function names are named poorly&amp;rdquo; — accept. &amp;ldquo;We already have a package, that solves a similar problem&amp;rdquo; — accept. &amp;ldquo;A change brings inconsistency to the codebase&amp;rdquo; — accept. &amp;ldquo;The pattern doesn’t belong here&amp;rdquo; — accept.
Go is a famously opinionated programming language. But does being opinionated help and scale outside of the language and its standard library?
Do you have the answer? Discuss this note on r/golang Reddit or share your thoughts on Twitter.</description></item><item><title>A thought experiment on Apple M1</title><link>https://vladimir.varank.in/notes/2020/11/a-thought-experiment-on-apple-m1/</link><pubDate>Tue, 24 Nov 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/11/a-thought-experiment-on-apple-m1/</guid><description>With Apple&amp;rsquo;s new M1 Macs showing (reportedly) huge performance improvement, compared to &amp;ldquo;old&amp;rdquo;, Intel-based Macs, I wonder what would hold Qualcomm (Snapdragon CPU) and others from doing &amp;ldquo;the same&amp;rdquo; and moving into laptop/desktop territory?
Microsoft already has Surface Pro X — an ARM-based Windows computer. They also have a version of Win10 for ARM, that one can even run on Raspberry Pi (still beta quality, I believe). Could 2021 become the year of ARM on desktop?
Even more interesting, Amazon&amp;rsquo;s Graviton is showing (again, reportedly) an excellent performance, while staying at reasonably low cost. What would stop Google/Microsoft from moving into ARM-based CPU territory for their clouds?</description></item><item><title>Alternative font-variant in VS Code</title><link>https://vladimir.varank.in/notes/2020/09/vscode-font-variant/</link><pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/09/vscode-font-variant/</guid><description>I&amp;rsquo;m not a big fun of the aesthetics of VS Code, at least not on macOS. In particular, I don&amp;rsquo;t like the way how its code editor renders fonts. But today I learned!
To make the fonts look better — I&amp;rsquo;m on macOS — set an alternative font-variant, e.g. &amp;ldquo;Comic Code Ligatures Medium&amp;rdquo; instead of &amp;ldquo;Regular&amp;rdquo;, in the editor&amp;rsquo;s settings. To specify font-variant, remove spaces in between the name of the font and pass the variant after the hyphen. That is, instead of 'Comic Code Ligatures', set the following:
&amp;#34;editor.fontFamily&amp;#34;: &amp;#34;&amp;#39;ComicCodeLigatures-Medium&amp;#39;, monospace&amp;#34; Full disclosure, my IDE of choice is GoLand, and it has been so since it was only a plugin for IntelliJ IDEA. Even though I can comfortably use VS Code or Vim when I need to make a small change or look something up in the code, I need the IDE to effectively work on a large codebase.
The backstory for this note is that I&amp;rsquo;m working on a small TypeScript/React application in my spare time this month. For something that small, VS Code works great fine. In fact, I&amp;rsquo;m writing this particular note in VS Code too ;)</description></item><item><title>One year in production</title><link>https://vladimir.varank.in/notes/2020/09/one-year-in-production/</link><pubDate>Tue, 01 Sep 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/09/one-year-in-production/</guid><description>It&amp;rsquo;s one year since I posted the very first note here. Unbelivable! Despite my own concerns I did published random posts over the course of the previous twelve months.
For the next round I came up with some personal goals:
Keep posting. Work on your grammar. Add &amp;ldquo;Archive&amp;rdquo; and &amp;ldquo;Tags&amp;rdquo; sections. Find a better approach for managing drafts. Bring back the dark theme but figure out what to do with the illustrations. Keep posting ;)</description></item><item><title>Does profefe prefers "push" over "pull"?</title><link>https://vladimir.varank.in/notes/2020/08/does-profefe-prefers-push-over-pull/</link><pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/08/does-profefe-prefers-push-over-pull/</guid><description>The main component of profefe, a system for continuous profiling, is profefe-collector — a service that receives profiling data, taken from an application and persists the data in collector’s storage (design document describes it in more details). Receiving data from an external source (for example, profefe-agent), indicates that profefe, as an observability system, prefers &amp;ldquo;push&amp;rdquo; model. Why not &amp;ldquo;pulling&amp;rdquo; the profiles directly from the application?
Both push and pull models have their benefits and drawbacks.
A collector that pulls profiling data from running applications could simplify integration into existing infrastructure because there would be no need in making changes in the applications that already exposed pprof HTTP endpoint. Making sure that every application integrated and configured profefe-agent would be a challenging job in a large organisation.
On the other hand, pull model requires pprof servers to be exposed and available for the collector, so it could fetch (pull) profiling data. That can also be challenging in the deployments, where applications are collocated on the bare-metal machines. Every application (application&amp;rsquo;s instance) would have to communicate a unique TCP port for its pprof server.
To work as a pull-system, the collector must be able to discover the pprof servers, thus it requires a mechanism for service discovery (SD), to be usable at scale. Unfortunately, there isn&amp;rsquo;t a universal SD protocol or a provider, an observability system could be built upon.
Prometheus, the best example of an open-source system, which uses pull model for data collection, have to support several different SD systems in their code base. At some point they ended up introducing their own general protocol, that expects a &amp;ldquo;middle-man-service&amp;rdquo;, which translates the data from a SD system into a list of Prometheus targets (Update, this comment from u/bbrazil does a better job explaining the state of SD in Prometheus). There is no clear way for an open-source system to be both flexible and don&amp;rsquo;t end up being a pile of &amp;ldquo;plugins&amp;rdquo;, that no one is willing to maintain or break.
From the start of profefe project, several years ago, I had the idea that translating push into pull would be easier for an end-user. That is if a small deployment already exposes a pprof server, writing an external job that pulls the profiles from the applications, annotates them with meta-data, and pushes the data into the collector, can be as easy as spawning a cronjob in a sidecar. kube-profefe solves that nicely for deployments running in Kubernetes. At some point, I hoped to come up with something similar for Nomad+Consul if the experiments ended successfully.
Translating pull into push is a similarly possible but because profefe didn’t have to support any SD mechanisms from the start, that simplified the overall code base and allowed us to focus on the collector and the API for profiles quering.
profefe-collector does uses push model. But one can deploy profefe so it reflected the use cases your organisation has.
Do you use continuous profiling? Let me know about your experience. Share your thoughts on Twitter or discuss on r/golang.</description></item><item><title>How to design a good API</title><link>https://vladimir.varank.in/notes/2020/08/how-to-design-a-good-api/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/08/how-to-design-a-good-api/</guid><description>A good API is designed around the use-case. A poorly designed, around the API&amp;rsquo;s implementation details.</description></item><item><title>What's in your main-dot-go? (aka Go Project boilerplate)</title><link>https://vladimir.varank.in/notes/2020/07/whats-in-your-main-dot-go/</link><pubDate>Fri, 31 Jul 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/07/whats-in-your-main-dot-go/</guid><description>Sometimes I write small services in Go from scratch. And every time main.go ends up looking almost the same:
func main() { ctx, cancel := context.WithCancel(context.Background()) defer cancel() sigs := make(chan os.Signal, 2) signal.Notify(sigs, os.Interrupt, syscall.SIGTERM) go func() { &amp;lt;-sigs signal.Stop(sigs) cancel() }() if err := run(ctx, os.Args[1:]); err != nil { log.Fatalln(err) } } type Config struct { HTTPAddr string HTTPShutdownTimeout time.Duration } func run(ctx context.Context, args []string) error { flags := flag.NewFlagSet(&amp;#34;&amp;#34;, flag.ExitOnError) var conf Config flags.StringVar(&amp;amp;conf.HTTPAddr, &amp;#34;http-addr&amp;#34;, &amp;#34;127.0.0.1:10080&amp;#34;, &amp;#34;address to listen on&amp;#34;) flags.DurationVar(&amp;amp;conf.HTTPShutdownTimeout, &amp;#34;http-shutdown-timeout&amp;#34;, 5*time.Second, &amp;#34;server shutdown timeout&amp;#34;) if err := flags.Parse(args); err != nil { return err } // TODO: define the handler, the routing, and wire the dependencies with the main context mux := http.NewServeMux() server := &amp;amp;http.Server{ Addr: conf.HTTPAddr, Handler: mux, } errs := make(chan error, 1) go func() { log.Printf(&amp;#34;starting: addr %s&amp;#34;, server.Addr) errs &amp;lt;- server.ListenAndServe() }() select { case &amp;lt;-ctx.Done(): log.Println(&amp;#34;exiting...&amp;#34;) case err := &amp;lt;-errs: return err } // create new context because top-most one is already canceled ctx, cancel := context.WithTimeout(context.Background(), conf.HTTPShutdownTimeout) defer cancel() return server.Shutdown(ctx) } Of course, not every service requires an HTTP server, but the general idea stands.
When Go will introduce signal.NotifyContext(), the signals handling in main() function will be much smaller (we&amp;rsquo;re at go1.15rc1 as I&amp;rsquo;m writing that and the change hasn&amp;rsquo;t landed into the release yet).
I love how transparent is the flow here and how everything is scoped inside run() function. This structure forces you to eliminate global state, making unit or integration testing almost trivial — at least, in theory ;)
It might feel like too much of boilerplate code for a &amp;ldquo;small&amp;rdquo; service. In practice, though, I don&amp;rsquo;t recall any time this caused any real troubles to me. The beauty of Go is in explicitness.</description></item><item><title>Waveshare ESP8266 Driver Board Pins Mapping</title><link>https://vladimir.varank.in/notes/2020/07/waveshare-esp8266-driver-board-pins-mapping/</link><pubDate>Tue, 14 Jul 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/07/waveshare-esp8266-driver-board-pins-mapping/</guid><description>I&amp;rsquo;ve been playing with an e-paper ESP866 Driver Board, and a 2.7&amp;quot; E-Ink display from Waveshare. Arduino C++ looks manageable. One strange thing, though. In both board’s documentation and GxEPD2 library’s examples, they say the display is connected to pins as BUSY → GPIO16, RST → GPIO5, DC → GPIO4, CS → GPIO15. This mapping seems wrong.
After digging through the code examples from Waveshare’s Wiki, the correct mapping is the following:
BUSY → GPIO5, RST → GPIO2, DC → GPIO4, CS → GPIO15
That&amp;rsquo;s how the initialisation of the main GxEPD2 class for my 2.7&amp;quot; display looks like now:
#define ENABLE_GxEPD2_GFX 0 #include &amp;lt;GxEPD2_BW.h&amp;gt; // mapping of Waveshare e-Paper ESP8266 Driver Board GxEPD2_BW&amp;lt;GxEPD2_270, GxEPD2_270::HEIGHT&amp;gt; display(GxEPD2_270(/*CS=15*/ SS, /*DC=4*/ 4, /*RST=2*/ 2, /*BUSY=5*/ 5));</description></item><item><title>Sticky headers? Please don't</title><link>https://vladimir.varank.in/notes/2020/06/sticky-headers/</link><pubDate>Wed, 17 Jun 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/06/sticky-headers/</guid><description>&lt;p>Sticky (or &amp;ldquo;&lt;em>fixed&lt;/em>&amp;rdquo;) headers are everywhere. It feels that, nowadays, every web designer’s first attempt to site&amp;rsquo;s navigation starts with a sticky header. I hate this.&lt;/p></description></item><item><title>Owner of Logging Context</title><link>https://vladimir.varank.in/notes/2020/04/owner-of-logging-context/</link><pubDate>Tue, 14 Apr 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/04/owner-of-logging-context/</guid><description>There’s the late-night dilemma&amp;hellip;
Who should be in charge of logging context: a component&amp;rsquo;s owner or the component itself?
type Logger interface { With(...kvpairs) Logger } type Storage struct { logger Logger } // OPTION 1: component&amp;#39;s owner defines the context of component&amp;#39;s logger func main() { _ = NewStorage(logger.With(&amp;#34;component&amp;#34;, &amp;#34;storage&amp;#34;)) } // OPTION 2: component itself is in charge of its logging context func NewStorage(logger Logger) (st *Storage) { return &amp;amp;Storage{ logger: logger.With(&amp;#34;component&amp;#34;, &amp;#34;storage&amp;#34;), } } Fun fact: a couple months back, we ruined the team&amp;rsquo;s Friday, by debating about a similar topic in the context of (Graphite) metrics namespaces. It has become even more intricate since then :/
Update (2020-04-15)
Many people on Twitter suggest that Option 1 is an obvious choice because only application knows how to name the components. I totally agree with that.
As I wrote later, the real dilemma is not about &amp;ldquo;application and component&amp;rdquo; but about &amp;ldquo;owner of the component&amp;rdquo;. Function main, in the example above, was a silly example, that tried (and failed) to illustrate the question in a code.
Let&amp;rsquo;s try another (silly) example:
// there are buch of different handlers (maybe ten) in this application type Handler1 struct { logger Logger } func (h *Handler1) ServeHTTP(w http.ResponseWriter, r *http.Request) { // OPTION 1 req := NewRequst(h.logger.With(&amp;#34;component&amp;#34;, &amp;#34;request&amp;#34;), r) } type Handler2 struct { logger Logger } func (h *Handler2) ServeHTTP(w http.ResponseWriter, r *http.Request) { // OPTION 1, still req := NewRequst(h.logger.With(&amp;#34;component&amp;#34;, &amp;#34;request&amp;#34;), r) } type Request struct { logger Logger } // OPTION 2 func NewRequst(logger Logger, *r http.Request) *Request { return &amp;amp;Request{ logger: logger.With(&amp;#34;component&amp;#34;, &amp;#34;request&amp;#34;), } } We want to have a consistent nomenclature across the application&amp;rsquo;s logs.
Is the choice still obvious? ;)
Do you have an opinion? Share it with me on Twitter.</description></item><item><title>Retrieve Location of macOS Device from Go</title><link>https://vladimir.varank.in/notes/2020/03/go-osx-core-location/</link><pubDate>Mon, 30 Mar 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/03/go-osx-core-location/</guid><description>&lt;p>Participating in self-isolation is more fun when you have toys to play. As a fun weekend project, I wanted to look at how one accesses macOS Location Services and get the geographic location of the device from Go.&lt;/p>
&lt;p>To obtain the geographic location of a device on macOS, we use &lt;a href="https://developer.apple.com/documentation/corelocation?language=objc">Apple’s Core Location&lt;/a> framework. The framework is part of the OS, but it requires writting Objective-C (&lt;em>or Swift&lt;/em>). Thanks to Go&amp;rsquo;s cgo and because Objective-C is from the family of C languages, we can write a bridge between Objective-C and Go.&lt;/p></description></item><item><title>Building Multi-Platform Docker Images with Travis CI and BuildKit</title><link>https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/</link><pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/01/buildkit-multi-platform-travis-ci/</guid><description>This is a lengthy note. If you don&amp;rsquo;t quite feel reading and only need the working example, go directly to the Travis CI build file.
The more I delve into the world of Raspberry Pi, the more I notice that &amp;ldquo;regular and boring&amp;rdquo; things on ARM are harder than I expected.
People build and distribute software exclusively for amd64. You read another &amp;ldquo;Kubernetes something&amp;rdquo; tutorial, that went viral on Twitter, and is fancy to try it out. Still, all helm charts, or whatever the author prefered, use Docker images built exclusively for amd64.
Docker toolchain has added the support for building multi-platform images in 19.x. However, it&amp;rsquo;s available only under the &amp;ldquo;experimental&amp;rdquo; mode. The topic of building multi-platform Docker images yet feels underrepresented.
But first, what are multi-platform Docker images? When a client, e.g. Docker client, tries to pull an image, it must negotiate the details about what exactly to pull with the registry. The registry provides a manifest that describes the digest of the requested image, the volumes the image consists of, the platform this image can run on, etc. Optionally, the registry can provide a manifests list, which, as the name suggests, is a list of several manifests bundled into one. With the manifests list in hands, the client can figure out the particular digest of the image it needs to pull.
So multi-platform Docker images are just several images, whose manifests are bundled into the manifests list.
Imagine we want to pull the image golang:1.13.6-alpine3.10. Docker client will get the manifests list from Dockerhub. This list includes digests of several images, each built for the particular platform. If we&amp;rsquo;re on Raspberry Pi, running the current Raspbian Linux, which is arm/v7, the client will pick the corresponding image&amp;rsquo;s digest. Alternatively, we could choose to pull the image arm32v7/golang:1.13.6-alpine3.10 instead, and we ended up with the same image with the digest d72fa60fb5b9. Of course, to use a single universal image name, i.e. golang, on every platform is way more convenient.
You can read more about manifests in Docker registry documentation.
Does it mean I need to build different Docker images, for each platform I want to support? Well, yes. This is how, official images are built.
For every platform, the image is built and pushed to the registry under the name &amp;lt;platform&amp;gt;/&amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;, e.g. amd64/golang:1-alpine. And next, a manifests list, that combines all those platform-specific images, is built and pushed with the simple name &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;.
Docker&amp;rsquo;s BuildKit provides a toolkit that, among other nice things, allows building multi-platform images on a single host. BuildKit is used inside Docker&amp;rsquo; buildx project, that is part of the recent Docker version.
One can use buildx, but, for this post, I wanted to try out, what would it look like to use BuildKit directly. For profefe, the system for continuous profiling of Go services, I set up Travis CI, that builds a multi-platform Docker image and pushes them to Dockerhub.
profefe is written in Go. That simplifies things, because, thanks to Go compiler, I don&amp;rsquo;t have to think about how to compile code for different platforms. The same Dockerfile will work fine on every platform.
Here&amp;rsquo;s how &amp;ldquo;deploy&amp;rdquo; stage of the build job looks like (see travis.yml on profefe&amp;rsquo;s GitHub).
dist: bionic language: go go: - 1.x jobs: include: - stage: deploy docker services: docker env: - PLATFORMS=&amp;#34;linux/amd64,linux/arm64,linux/arm/v7&amp;#34; install: - docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes - docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest - sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/ - export BUILDKIT_HOST=&amp;#34;docker-container://buildkitd&amp;#34; script: skip deploy: - provider: script script: | buildctl build \ --progress=plain \ --frontend=dockerfile.v0 \ --local context=. --local dockerfile=. \ --opt filename=contrib/docker/Dockerfile \ --opt platform=$PLATFORMS \ --opt build-arg:VERSION=\&amp;#34;master\&amp;#34; \ --opt build-arg:GITSHA=\&amp;#34;$TRAVIS_COMMIT\&amp;#34; \ --output type=image,\&amp;#34;name=profefe/profefe:git-master\&amp;#34;,push=true on: repo: profefe/profefe branch: master before_deploy: - echo &amp;#34;$DOCKER_PASSWORD&amp;#34; | docker login --username &amp;#34;$DOCKER_USERNAME&amp;#34; --password-stdin after_failure: - buildctl debug workers ls - docker container logs buildkitd It&amp;rsquo;s a lot happening here, but I&amp;rsquo;ll describe the most critical parts.
Let&amp;rsquo;s start with dist: bionic.
We run the builds under Ubuntu 18.04 (Bionic Beaver). To be able to build multi-platform images on a single amd64 host, BuildKit uses QEMU to emulate other platforms. That requires Linux kernel 4.8, so even Ubuntu 16.04 (Xenial Xerus) should work.
The top-level details on how the emulation works are very well described in https://www.kernel.org/doc/html/latest/admin-guide/binfmt-misc.html
In short, we tell the component of the kernel (binfmt_misc) to use QEMU when the system executes a binaries built for a different platform. The following call in the &amp;ldquo;install&amp;rdquo; step is what&amp;rsquo;s doing that:
- docker container run --rm --privileged multiarch/qemu-user-static --reset -p yes Under the hood, the container runs a shell script from QEMU project, that registers the emulator as an executor of binaries from the external platforms.
If you think, that running a docker container to do the manipulations with the host&amp;rsquo;s OS looks weird, well&amp;hellip; I can&amp;rsquo;t agree more. Probably, a better approach would be to install qemu-user-static, which would do the proper setup. Unfortunately, the current package&amp;rsquo;s version for Ubuntu Bionic doesn&amp;rsquo;t do the registration as we need it. I.e. its post-install doesn&amp;rsquo;t add the &amp;quot;F&amp;quot; flag (&amp;ldquo;fix binaries&amp;rdquo;), which is crucial for our goal. Let&amp;rsquo;s just agree,that docker-run will do ok for the demonstrational purpose.
- docker container run -d --rm --name buildkitd --privileged moby/buildkit:latest - sudo docker container cp buildkitd:/usr/bin/buildctl /usr/local/bin/ - export BUILDKIT_HOST=&amp;#34;docker-container://buildkitd&amp;#34; This is another &amp;ldquo;docker-run&amp;rsquo;ism&amp;rdquo;. We start BuildKit&amp;rsquo;s buildkitd daemon inside the container, attaching it to the Docker daemon that runs on the host (&amp;ldquo;privileged&amp;rdquo; mode). Next, we copy buildctl binary from the container to the host system and set BUILDKIT_HOST environment variable, so buildctl knew where its daemon runs.
Alternatively, we could install BuildKit from GitHub and run the daemon directly on the build host. YOLO.
before_deploy: - echo &amp;#34;$DOCKER_PASSWORD&amp;#34; | docker login --username &amp;#34;$DOCKER_USERNAME&amp;#34; --password-stdin To be able to push the images to the registry, we need to log in providing Docker credentials to host&amp;rsquo;s Docker daemon. The credentials are set as Travis CI&amp;rsquo;s encrypted environment variables ([refer to Travis CI docs])](https://docs.travis-ci.com/user/environment-variables/)).
buildctl build \ --progress=plain \ --frontend=dockerfile.v0 \ --local context=. --local dockerfile=. \ --opt filename=contrib/docker/Dockerfile \ --opt platform=$PLATFORMS \ --opt build-arg:VERSION=\&amp;#34;master\&amp;#34; \ --opt build-arg:GITSHA=\&amp;#34;$TRAVIS_COMMIT\&amp;#34; \ --output type=image,\&amp;#34;name=profefe/profefe:git-master\&amp;#34;,push=true This is the black box where everything happens. Magically!
We run buildctl stating that it must use the specified Dockerfile; it must build the images for defined platforms (I specified linux/amd64,linux/arm64,linux/arm/v7), create a manifests list tagged as the desired image (profefe/profefe:&amp;lt;version&amp;gt;), and push all the images to the registry.
buildctl debug workers ls shows what platforms does BuildKit on this host support. I listed only those I&amp;rsquo;m currently intrested with.
And that&amp;rsquo;s all. This setup automatically builds and pushes multi-platform Docker images for profefe (https://hub.docker.com/p/profefe/profefe) on a commit to project&amp;rsquo;s &amp;ldquo;master&amp;rdquo; branch on GitHub.
As I hope you&amp;rsquo;ve seen, support for multi-platform is getting easier and things that were hard a year ago are only mildly annoying now :)
If you have any comments or suggestions, reach out to me on Twitter or discuss this note on r/docker Reddit.
Some more reading on the topic:
Documentation for BuildKit project Building multi-platform images with docker and buildx Docker Official Images are now Multi-platform, Docker official announcement</description></item><item><title>k3s with Ubuntu Server (arm64) on Raspberry Pi 4</title><link>https://vladimir.varank.in/notes/2020/01/raspi-ubuntu-arm64-k3s/</link><pubDate>Sat, 11 Jan 2020 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2020/01/raspi-ubuntu-arm64-k3s/</guid><description>&lt;p>As I&amp;rsquo;ve &lt;a href="https://twitter.com/tvii/status/1215927299557797893?s=20">twitted&lt;/a> recently, I&amp;rsquo;m updating one of my Raspberry Pis to &lt;a href="https://ubuntu.com/download/raspberry-pi">Ubuntu Server 19.10 (arm64)&lt;/a>.&lt;/p>
&lt;h2 id="one-of-raspberry-pis">&amp;ldquo;One of Raspberry Pis&amp;rdquo;?&lt;/h2>
&lt;p>My home cluster is four &lt;a href="https://www.raspberrypi.org/products/raspberry-pi-4-model-b/?variant=raspberry-pi-4-model-b-2gb">Raspberry Pis 4 (2GB)&lt;/a>; all connected to my internet router through ethernet and
powered with &lt;a href="https://www.amazon.de/gp/product/B00PTLSH9G/ref=ppx_yo_dt_b_asin_title_o03_s00?ie=UTF8&amp;amp;psc=1">60W 6 USB-ports charger&lt;/a>. All Pis build a small Kubernetes cluster that runs with &lt;a href="https://k3s.io/">k3s&lt;/a>.&lt;/p>
&lt;p>All by one Pis run on &lt;a href="https://www.raspberrypi.org/downloads/raspbian/">Raspbian Buster Lite&lt;/a> and this setup&amp;rsquo;s been working pretty well until I&amp;rsquo;ve found out,
&lt;a href="https://www.aerospike.com/">Aerospike&lt;/a>, a database I required to run for a testing lab, only works on a 64-bit OS.&lt;/p>
&lt;p>Luckily, &lt;a href="https://ubuntu.com/download/raspberry-pi">Ubuntu Server has an arm64 version&lt;/a> built for Raspberry Pi. Thus, my working plan is to switch one Pi
to Ubuntu, compile and run a single-instance Aerospike server (&lt;em>and any other components, that require a 64-bit OS&lt;/em>) on this Pi, and provide a Kubernetes service in front of the DB, so other components in the cluster could access it as if it was
fully managed by Kubernetes.&lt;/p></description></item><item><title>The Fireside Edition</title><link>https://vladimir.varank.in/notes/2019/12/the-fireside-edition/</link><pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/12/the-fireside-edition/</guid><description>After listening to the “Fireside edition” of Go Time, I questioned myself, how would I answered the questions the hosts discussed.
Because no one has asked, you are very welcome:
1. If you had two weeks to spend on a personal Go project, what would you work on? I really want to invest more time for profefe. Specifically, on implementing an analyser of stored profiles: the thing that would help to make sense of the data, showing how the performance of an instance, a node, or a cluster had changed over the period of time; how different parts of the codebase had influenced the performance of the application.
Recently Amazon has announced CodeGuru profiler (currently Java-only). From the description it feels exactly what I pictured in my head when I started the project.
Another topic that I would like to invest more time on is the understanding of the ecosystem around/inside Kubernetes. During the past two years, I slowed down the consumption of the DevOps/SRE topics, mostly due to the specific state of the infrastructure in our company. But, &amp;ldquo;k8s is the new linux&amp;rdquo;, regardless of what one&amp;rsquo;s opinion on that. Even profefe recently has ended up having a kube-profefe (a bridge between profefe and Kubernetes), contributed and maintained by other people.
2. What annoys you about Go of 2019? The same small things that annoyed me in Go 1.4: var, new, make and &amp;ldquo;naked return&amp;rdquo;. Sure, I understand that they all ended up in the language for a reason. But I simply don&amp;rsquo;t like the &amp;ldquo;magic&amp;rdquo; of make, which works only with particular types; the two ways of defining a variable (var or :=), or a pointer to an instance of a type (new or &amp;amp;T{}).
One new thing, though. Go modules&amp;rsquo; semver imports. But I can&amp;rsquo;t say anything new about that. Probably, I just need to embrace them. Go 1.14 looks like a version where I might completely switch to modules, thanks to better handling of vendored dependencies.
3. What&amp;rsquo;s your ideal working environment? That always surprises me. Lots of people keep saying that working from home is their ideal environment or even a factor that influence their job offers choice. I don&amp;rsquo;t like to work at home. The only time when I feel productive when stay home is in the nights. A café or a co-working works sometimes. But I like working in a big office space. I don&amp;rsquo;t know why.
Of course, open-plan offices can be very different. Yandex&amp;rsquo;s “Red Rose” is still the best space I ever worked in. I heard they do excursions around the Moscow&amp;rsquo;s office now.
3.1. Something on pair-programming? Since I wrote about Yandex.
Some people think pair-programming is a sort of super-power. It&amp;rsquo;s, and it&amp;rsquo;s not. You can&amp;rsquo;t just put yourself in an environment, where someone is watching how you write the code while trying to hold a conversation about the code architecture. Pair-programming is a skill to master. But it pays off.
The pair-(trio actually)-programming sessions we did in Yandex, when we worked on bem-core, was the most significant skill boost I had during the five-plus years there.
Of course, the positive experience comes from your peers. In my case, they were people with huge baggage of knowledge and practice of working, talking, debating with each other. Like, out of nowhere, you get the understanding of what types of questions you must ask; when it is important to spend more time on thinking and when you can make a small hack.
4. Your advice to you junior-developer self? Don&amp;rsquo;t overthink and afraid of starting anything. Trying something by making a raw, dirty, barely-working prototype will give you way more knowledge than thinking about how to do that.</description></item><item><title>[]byte to string conversion</title><link>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</link><pubDate>Tue, 08 Oct 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/10/go-bytes-string-conversion/</guid><description>Go has an old wiki page, titled &amp;ldquo;Compiler And Runtime Optimizations&amp;rdquo;.
The part I like most there is different cases where compiler doesn&amp;rsquo;t allocate memory for string to []byte conversions:
For a map m of type map[string]T and []byte b, m[string(b)] doesn&amp;rsquo;t allocate (the temporary string copy of the byte slice isn&amp;rsquo;t made)
Turned out, since this wiki page was written, more similar optimisations were added to the compiler.
As it&amp;rsquo;s in Go 1.12+ the following cases are also listed in runtime/string.go:
Strings comcatenation For the case &amp;quot;&amp;lt;&amp;quot; + string(b) + &amp;quot;&amp;gt;&amp;quot;, where b is []byte no extra copying of b is needed.
Comparison if string(b) == &amp;#34;foo&amp;#34; { ··· } In the code above, b []byte also won&amp;rsquo;t be copied.
There are still cases where compiler can&amp;rsquo;t optimise the code for us. In some of those cases it&amp;rsquo;s fine to do string to bytes conversion using a so called &amp;ldquo;unsafe trick&amp;rdquo; (accessing string&amp;rsquo;s underling data directly, with out copying the data from string to bytes and vice versa). One can find several ways of performing the trick, but none of them seems &amp;ldquo;the one that must be used&amp;rdquo;.
After years of episodic discussions, a collegue of mine assembled the list of different conserns and about the proper way of doing it (see &amp;ldquo;unsafe conversion between string &amp;lt;-&amp;gt; []byte&amp;rdquo; topic on golang-nuts forum). Thanks to replies from Go team, our most valid way of doing it is following:
// Refer to github.com/fmstephe/unsafeutil type stringHeader struct { data unsafe.Pointer stringLen int } type sliceHeader struct { data unsafe.Pointer sliceLen int sliceCap int } func StringToBytes(s string) (b []byte) { stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) sliceHeader.data = stringHeader.data sliceHeader.sliceLen = len(s) sliceHeader.sliceCap = len(s) return b } func BytesToString(b []byte) (s string) { sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;amp;b)) stringHeader := (*stringHeader)(unsafe.Pointer(&amp;amp;s)) stringHeader.data = sliceHeader.data stringHeader.stringLen = len(b) return s }</description></item><item><title>Github Actions and GOPATH</title><link>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</guid><description>The other day I received my beta access to GitHub Actions. To try them out I picked an existing pet project and created a workflow using a Go project template provided by GitHub. As it&amp;rsquo;s in September 2019, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.
My project is a classic Go service ;) meaning: it uses vendoring and doesn&amp;rsquo;t use Go modules. So no need for &amp;ldquo;get dependencies&amp;rdquo; step. And it requires to be inside the GOPATH. With that, the provided workflow needed some adjustment.
After some trials and errors, I&amp;rsquo;ve managed to make checkout step to clone the repo into the correct destination inside the GOPATH. Here is the final workflow:
name: Run Go test on: [pull_request] jobs: test: strategy: matrix: go-version: [1.12.9] runs-on: ubuntu-latest steps: - uses: actions/setup-go@v1 with: go-version: ${{ matrix.go-version }} - uses: actions/checkout@v1 with: path: ./src/github.com/${{ github.repository }} fetch-depth: 5 - run: make test env: GOPATH: ${{ runner.workspace }} Note, how actions/checkout@v1 above uses custom path input parameter. I set the path to ./src/github.com/${{ github.repository }}, so the project is checked out to src directory in the runners&amp;rsquo;s workspace, which I later pass as the value of GOPATH to the &amp;ldquo;make test&amp;rdquo; step. The leading dot in ./src seems very important — I&amp;rsquo;ve spent the majority of the time trying to figure out that part — refer to this issue.
See the workflow in action.
To learn more about those ${{ ··· }} &amp;ldquo;macroses&amp;rdquo; I suggest looking at the Actions&amp;rsquo; &amp;ldquo;Contexts and expression syntax&amp;rdquo; documentation.</description></item><item><title>Go's net/http.Headers</title><link>https://vladimir.varank.in/notes/2019/09/go-http-headers/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/go-http-headers/</guid><description>One probably knows that net/http.Headers is no more than map[string][]string with extra specific methods. A usual way to initialize and populate such data-structure from an external representation is something like that:
type Header map[string][]string func (h Header) Add(key, val string) { if val == &amp;#34;&amp;#34; { return } h[key] = append(h[key], val) } func main() { h := make(Header) h.Add(&amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) h.Add(&amp;#34;Via&amp;#34;, &amp;#34;b.example.com&amp;#34;) } From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&amp;rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&amp;rsquo;d like to avoid.
I was curious to know if Go&amp;rsquo;s standard library cares about that.
Looking at the implementation of net/textproto.Reader.ReadMIMEHeader(), which is used in the standard HTTP server, or Go 1.13’s new net/http.Header.Clone(), it turned out they solve the problem quite elegantly.
We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.
Knowing that, we can refactor the initial Header.Add as the following:
type Header map[string][]string func (h Header) add(vv []string, key, val string) []string { if val == &amp;#34;&amp;#34; { ··· } // fast path for KV pair of a single value if h[key] == nil { vv = append(vv, value) h[key] = vv[:1:1] return vv[1:] } // slow path, when KV pair has two or more values h[key] = append(h[key], val) return vv } func main() { h := make(Header) // net/textprotocol pre-counts total number of request&amp;#39;s headers // to allocate the slice of known capacity vv := make([]string, 0) vv = h.add(vv, &amp;#34;Host&amp;#34;, &amp;#34;example.com&amp;#34;) vv = h.add(vv, &amp;#34;Via&amp;#34;, &amp;#34;a.example.com&amp;#34;) } Note that we use vv[:1:1] to create a sub-slice of a fixed capacity (length 1, capacity 1).
If there is a KV-pair that has several values, e.g. &amp;ldquo;Via&amp;rdquo; header, Add will allocate a separate slice for that key, doubling its capacity.</description></item><item><title>Hello World</title><link>https://vladimir.varank.in/notes/2019/09/hello-world/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/hello-world/</guid><description>Let&amp;rsquo;s create a blog. But let&amp;rsquo;s call them &amp;ldquo;notes&amp;rdquo;.
Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</description></item></channel></rss>