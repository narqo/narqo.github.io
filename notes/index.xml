<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/</link><description>Recent content in Notes on Vladimir Varankin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 04 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Go&#39;s net/http.Headers</title><link>https://vladimir.varank.in/notes/2019/09/go-http-headers/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/go-http-headers/</guid><description>One probably knows that net/http.Headers is no more than map[string][]string with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:
type Header map[string][]string func (h Header) Add(key, val string) { if val == &amp;quot;&amp;quot; { return } h[key] = append(h[key], val) } func main() { h := make(Header) h.Add(&amp;quot;Host&amp;quot;, &amp;quot;example.com&amp;quot;) h.Add(&amp;quot;Via&amp;quot;, &amp;quot;a.example.com&amp;quot;) h.Add(&amp;quot;Via&amp;quot;, &amp;quot;b.example.com&amp;quot;) } From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&amp;rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&amp;rsquo;d like to avoid.
I was curious to know if Go&amp;rsquo;s standard library cares about that.
Looking at the implementation of net/textproto.Reader.ReadMIMEHeader(), which&amp;rsquo;s used in the standard HTTP server, or Go 1.13’s new net/http.Header.Copy(), it turned out they solve the problem quit elegantly.
We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.
Knowing that, we can refactor the initial Header.Add as the following:
type Header map[string][]string func (h Header) add(vv []string, key, val string) []string { if val == &amp;quot;&amp;quot; { ··· } // fast path for KV pair of a single value if h[key] == nil { vv = append(vv, value) h[key] = vv[:1:1] return vv[1:] } // slow path, when KV pair has two or more values h[key] = append(h[key], val) return vv } func main() { h := make(Header) // net/textprotocol pre-counts total number of request&#39;s headers // to allocate the slice of known capacity vv := make([]string, 0) vv = h.add(vv, &amp;quot;Host&amp;quot;, &amp;quot;example.com&amp;quot;) vv = h.add(vv, &amp;quot;Via&amp;quot;, &amp;quot;a.example.com&amp;quot;) } Note that we use vv[:1:1] to create a subslice of the fixed capacity (length 1, capacity 1).
If there is a KV-pair that has several values, e.g. &amp;ldquo;Via&amp;rdquo; header, Add will allocate a separate slice for that key, doubling its capacity.</description></item><item><title>Hello World</title><link>https://vladimir.varank.in/notes/2019/09/hello-world/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/hello-world/</guid><description>Let&amp;rsquo;s create a blog. But let&amp;rsquo;s call them &amp;ldquo;notes&amp;rdquo;.
Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</description></item></channel></rss>