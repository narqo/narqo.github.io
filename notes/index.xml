<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Notes on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/</link><description>Recent content in Notes on Vladimir Varankin</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 19 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/index.xml" rel="self" type="application/rss+xml"/><item><title>Github Actions and GOPATH</title><link>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</link><pubDate>Thu, 19 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/github-actions-and-gopath/</guid><description>The other day I received my beta access to GitHub Actions. To try them out I picked an existing pet project and created a workflow using a Go project template provided by GitHub. As it&amp;rsquo;s in September 2019, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.
My project is a classic Go service ;) meaning: it uses vendoring and doesn&amp;rsquo;t use Go modules. So no need for &amp;ldquo;get dependencies&amp;rdquo; step. And it requires to be inside the GOPATH. With that, the provided workflow needed some adjustment.
After some trials and errors, I&amp;rsquo;ve managed to make checkout step to clone the repo into the correct destination inside the GOPATH. Here is the final workflow:
name: Run Go test on: [pull_request] jobs: test: strategy: matrix: go-version: [1.12.9] runs-on: ubuntu-latest steps: - uses: actions/setup-go@v1 with: go-version: ${{ matrix.go-version }} - uses: actions/checkout@v1 with: path: ./src/github.com/${{ github.repository }} fetch-depth: 5 - run: make test env: GOPATH: ${{ runner.workspace }} Note, how actions/checkout@v1 above uses custom path input parameter. I set the path to ./src/github.com/${{ github.repository }}, so the project is checked out to src directory in the runners&amp;rsquo;s workspace, which I later pass as the value of GOPATH to the &amp;ldquo;make test&amp;rdquo; step. The leading dot in ./src seems very important — I&amp;rsquo;ve spent the majority of the time trying to figure out that part — refer to this issue.
See the workflow in action.
To learn more about those ${{ ··· }} &amp;ldquo;macroses&amp;rdquo; I suggest looking at the Actions&amp;rsquo; &amp;ldquo;Contexts and expression syntax&amp;rdquo; documentation.</description></item><item><title>Go&#39;s net/http.Headers</title><link>https://vladimir.varank.in/notes/2019/09/go-http-headers/</link><pubDate>Wed, 04 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/go-http-headers/</guid><description>One probably knows that net/http.Headers is no more than map[string][]string with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:
type Header map[string][]string func (h Header) Add(key, val string) { if val == &amp;quot;&amp;quot; { return } h[key] = append(h[key], val) } func main() { h := make(Header) h.Add(&amp;quot;Host&amp;quot;, &amp;quot;example.com&amp;quot;) h.Add(&amp;quot;Via&amp;quot;, &amp;quot;a.example.com&amp;quot;) h.Add(&amp;quot;Via&amp;quot;, &amp;quot;b.example.com&amp;quot;) } From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&amp;rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&amp;rsquo;d like to avoid.
I was curious to know if Go&amp;rsquo;s standard library cares about that.
Looking at the implementation of net/textproto.Reader.ReadMIMEHeader(), which&amp;rsquo;s used in the standard HTTP server, or Go 1.13’s new net/http.Header.Copy(), it turned out they solve the problem quit elegantly.
We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.
Knowing that, we can refactor the initial Header.Add as the following:
type Header map[string][]string func (h Header) add(vv []string, key, val string) []string { if val == &amp;quot;&amp;quot; { ··· } // fast path for KV pair of a single value if h[key] == nil { vv = append(vv, value) h[key] = vv[:1:1] return vv[1:] } // slow path, when KV pair has two or more values h[key] = append(h[key], val) return vv } func main() { h := make(Header) // net/textprotocol pre-counts total number of request&#39;s headers // to allocate the slice of known capacity vv := make([]string, 0) vv = h.add(vv, &amp;quot;Host&amp;quot;, &amp;quot;example.com&amp;quot;) vv = h.add(vv, &amp;quot;Via&amp;quot;, &amp;quot;a.example.com&amp;quot;) } Note that we use vv[:1:1] to create a subslice of the fixed capacity (length 1, capacity 1).
If there is a KV-pair that has several values, e.g. &amp;ldquo;Via&amp;rdquo; header, Add will allocate a separate slice for that key, doubling its capacity.</description></item><item><title>Hello World</title><link>https://vladimir.varank.in/notes/2019/09/hello-world/</link><pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2019/09/hello-world/</guid><description>Let&amp;rsquo;s create a blog. But let&amp;rsquo;s call them &amp;ldquo;notes&amp;rdquo;.
Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</description></item></channel></rss>