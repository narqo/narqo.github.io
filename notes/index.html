<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Notes - Vladimir Varankin</title><style>:root{--background-color: #fff;--text-color: #111;--header-color: #111;--link-color: rgb(0, 16, 161);--link-underline-color: rgba(0, 16, 161, 0.3);--link-hover-color: rgb(190, 0, 0);--link-hover-underline-color: rgba(190, 0, 0, 0.3)}@media(prefers-color-scheme:dark){:root.theme-dark{--background-color: #181818;--text-color: #cfcfcf;--header-color: #fefefe;--link-color: rgb(85, 172, 255);--link-underline-color: rgb(85, 172, 255, 0.8);--link-hover-color: rgb(231, 66, 66);--link-hover-underline-color: rgb(231, 66, 66, 0.8)}}body{background:var(--background-color);color:var(--text-color);font-family:Charter,Georgia,serif;font-size:16px;line-height:1.45;margin:8px 12px}h1,h2,h3,h4{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1}h1{font-size:40px;margin:.5em 0 .2em}a{color:#0010a1;color:var(--link-color);text-decoration-color:var(--link-underline-color)}a:hover,a:active{color:#be0000;color:var(--link-hover-color);text-decoration-color:var(--link-hover-underline-color)}pre{line-height:1.3}code{font-family:Menlo,Consolas,monospace;font-size:14px}hr{border:none;border-bottom:1px solid;width:90%}.main-nav{letter-spacing:.3em;padding-bottom:16px}.main-nav a,.main-nav span{letter-spacing:0}.main-content{max-width:900px}.main-footer{margin:50px 0 0}.article{margin:0 0 50px}.article-meta{font-size:14px;line-height:1}.tag{margin:0 0 0 .7em}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes class=item-current>Notes</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=main-head><h1>Notes</h1></header><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/12/the-fireside-edition/>The Fireside Edition</a></h2></header><p>After listening to the &ldquo;Fireside edition&rdquo; of <a href=https://changelog.com/gotime/110>Go Time FM</a>, I questioned myself, how would I answered the questions the hosts discussed.</p><p>Because no one has asked, you are very welcome:</p><h2 id=1-if-you-had-two-weeks-to-spend-on-a-personal-go-project-what-would-you-work-on>1. If you had two weeks to spend on a personal Go project, what would you work on?</h2><p>I really want to invest more time for <a href=https://github.com/profefe/profefe>profefe</a>. Specifically,
on implementing an analyser of stored profiles: the thing that would help to make sense of the data,
showing how the performance of an instance, a node, or a cluster had changed over the period of time;
how different parts of the codebase had influenced the performance of the application.</p><p>Recently Amazon has announced CodeGuru profiler (currently Java-only). From <a href=https://aws.amazon.com/codeguru/faqs/#Amazon_CodeGuru_Profiler>the description</a> it feels
exactly what I pictured in my head when I started the project.</p><p>Another topic that I would like to invest more time on is the understanding of the ecosystem around/inside Kubernetes.
During the past two years, I slowed down the consumption of the DevOps/SRE topics, mostly due to the specific
state of the infrastructure in our company. But, &ldquo;<em>k8s is the new linux</em>", regardless of what one's opinion on that.
Even profefe recently has ended up having a <a href=https://github.com/profefe/kube-profefe>kube-profefe</a> (<em>a bridge between profefe and Kubernetes</em>), contributed and maintained by other people.</p><h2 id=2-what-annoys-you-about-go-of-2019>2. What annoys you about Go of 2019?</h2><p>The same small things that annoyed me in Go 1.4: <code>var</code>, <code>new</code>, <code>make</code> and &ldquo;naked return&rdquo;. Sure, I understand that they all ended up in the language for a reason. But I simply don't like the &ldquo;magic&rdquo; of <code>make</code>, which works only with particular types;
the two ways of defining a variable (<code>var</code> or <code>:=</code>), or a pointer to an instance of a type (<code>new</code> or <code>&T{}</code>).</p><p>One new thing, though. Go modules&rsquo; semver imports. But I can't say anything new about that. Probably, I just need to embrase them. Go 1.14 looks like a version where I might completely switch to modules, thanks to better handling of vendored dependencies.</p><h2 id=3-whats-your-ideal-working-environment>3. What's your ideal working environment?</h2><p>That always surprises me. Lots of people keep saying that working from home is their ideal environment or even a factor
that influence their job offers choice. I don't like to work at home. The only time when I feel productive when stay home is in the nights. A cafe or a co-working works sometimes. But I like working in a big office space. I don't know why.</p><p>Of course, open-plan offices can be very different. Yandex's &ldquo;Red Rose&rdquo; is still the best space I ever worked in. I heard they do excursions around the Moscow's office now.</p><h3 id=31-something-on-pair-programming>3.1. Something on pair-programming?</h3><p><em>Since I wrote about Yandex.</em></p><p>Some people thing pair-programming is a sort of a super-power. It's, and it's not.
You can't just put yourself in an environment, where someone is watching how you write the code while trying to hold a conversation about the code architecture. Pair-programming is a skill to master. But it pays off.</p><p>The pair-(trio actually)-programming sessions we did in Yandex, when we worked on <a href=https://github.com/bem/bem-core>bem-core</a>, was the most significant skill boost I had during the five+ years their.</p><p>Of course, the positive experience comes from your peers. In my case, they were people with a huge baggage of knowledge and practice of working, talking, debating with each other. Like, out of nowhere, you get the understanding of what
types of questions you must ask; when it is important to spend more time on thinking and when you can make a small hack.</p><h2 id=4-your-advice-to-you-junior-developer-self>4. Your advice to you junior-developer self?</h2><p>Don't overthink and afraid of starting anything. Trying something by making a raw, dirty, barely-working prototype will give you way more knowledge than thinking about how to do that.</p><footer class=article-meta><time datetime=2019-12-23T12:00:00Z>December 23, 2019</time><span class=tag>go</span><span class=tag>go time fm</span><span class=tag>askme</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/10/go-bytes-string-conversion/>[]byte to string conversion</a></h2></header><p>Go has an old wiki page, titled &ldquo;<a href=https://github.com/golang/go/wiki/CompilerOptimizations>Compiler And Runtime Optimizations</a>".</p><p>The part I like most there is different cases where compiler doesn't allocate memory for <code>string</code> to <code>[]byte</code> conversions:</p><blockquote><p>For a map m of type <code>map[string]T</code> and <code>[]byte b</code>, <code>m[string(b)]</code> doesn't allocate (the temporary string copy of the byte slice isn't made)</p></blockquote><p>Turned out, since this wiki page was written, more similar optimisations were added to the compiler.</p><p>As it's in Go 1.12+ the following cases are also listed in <a href=https://github.com/golang/go/blob/release-branch.go1.12/src/runtime/string.go#L128-L153><code>runtime/string.go</code></a>:</p><ul><li>Strings comcatenation</li></ul><p>For the case <code>"&lt;" + string(b) + ">"</code>, where <code>b</code> is <code>[]byte</code> no extra copying of <code>b</code> is needed.</p><ul><li>Comparison</li></ul><pre><code>if string(b) == &quot;foo&quot; { ··· }
</code></pre><p>In the code above, <code>b []byte</code> also won't be copied.</p><hr><p>There are still cases where compiler can't optimise the code for us. In some of those cases
it's fine to do string to bytes conversion using a so called &ldquo;<code>unsafe</code> trick&rdquo; (accessing string's underling
data directly, with out copying the data from string to bytes and vice versa). One can find several
ways of performing the trick, but none of them seems &ldquo;the one that must be used&rdquo;.</p><p>After years of episodic discussions, a collegue of mine assembled the list of different conserns and about
the proper way of doing it (<em>see &ldquo;<a href=https://groups.google.com/d/topic/golang-nuts/Zsfk-VMd_fU/discussion>unsafe conversion between string &lt;-> []byte</a>&rdquo; topic on golang-nuts forum</em>).
Thanks to replies from Go team, our most valid way of doing it is following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:green>// Refer to github.com/fmstephe/unsafeutil
</span><span style=color:green></span>
<span style=color:#00f>type</span> stringHeader <span style=color:#00f>struct</span> {
	data      unsafe.Pointer
	stringLen <span style=color:#2b91af>int</span>
}

<span style=color:#00f>type</span> sliceHeader <span style=color:#00f>struct</span> {
	data     unsafe.Pointer
	sliceLen <span style=color:#2b91af>int</span>
	sliceCap <span style=color:#2b91af>int</span>
}

<span style=color:#00f>func</span> StringToBytes(s <span style=color:#2b91af>string</span>) (b []<span style=color:#2b91af>byte</span>) {
	stringHeader := (*stringHeader)(unsafe.Pointer(&amp;s))
	sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;b))
	sliceHeader.data = stringHeader.data
	sliceHeader.sliceLen = len(s)
	sliceHeader.sliceCap = len(s)
	<span style=color:#00f>return</span> b
}

<span style=color:#00f>func</span> BytesToString(b []<span style=color:#2b91af>byte</span>) (s <span style=color:#2b91af>string</span>) {
	sliceHeader := (*sliceHeader)(unsafe.Pointer(&amp;b))
	stringHeader := (*stringHeader)(unsafe.Pointer(&amp;s))
	stringHeader.data = sliceHeader.data
	stringHeader.stringLen = len(b)
	<span style=color:#00f>return</span> s
}
</code></pre></div><footer class=article-meta><time datetime=2019-10-08T12:00:00Z>October 8, 2019</time><span class=tag>go</span><span class=tag>µ-benchmarks</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/github-actions-and-gopath/>Github Actions and GOPATH</a></h2></header><p>The other day I received my beta access to <a href=https://github.com/features/actions>GitHub Actions</a>. To try them out I picked an existing pet project and created a <em>workflow</em> using a Go project template provided by GitHub. As it's in <em>September 2019</em>, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.</p><p>My project is a <em>classic Go service</em> ;) meaning: it uses vendoring and doesn't use Go modules. So no need for &ldquo;get dependencies&rdquo; step. And it requires to be inside the <code>GOPATH</code>. With that, the provided workflow needed some adjustment.</p><p>After some trials and errors, I've managed to make <code>checkout</code> step to clone the repo into the correct destination inside the <code>GOPATH</code>. Here is the final workflow:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml>name: Run Go test
on: [pull_request]
jobs:
  test:
    strategy:
      matrix:
        go-version: [1.12.9]

    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-go@v1
        with:
          go-version: ${{ matrix.go-version }}

      - uses: actions/checkout@v1
        with:
          path: ./src/github.com/${{ github.repository }}
          fetch-depth: 5

      - run: make test
        env:
          GOPATH: ${{ runner.workspace }}
</code></pre></div><p>Note, how <code>actions/checkout@v1</code> above uses custom <code>path</code> input parameter. I set the path to <code>./src/github.com/${{ github.repository }}</code>, so the project is checked out to <code>src</code> directory in the runners's workspace, which I later pass as the value of <code>GOPATH</code> to the &ldquo;make test&rdquo; step. The leading dot in <code>./src</code> seems very important — I've spent the majority of the time trying to figure out that part — refer to <a href=https://github.com/actions/checkout/issues/41>this issue</a>.</p><p><a href=https://github.com/profefe/profefe/actions>See the workflow in action</a>.</p><p>To learn more about those <code>${{ ··· }}</code> &ldquo;macroses&rdquo; I suggest looking at the Actions&rsquo; &ldquo;<a href=https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions>Contexts and expression syntax</a>&rdquo; documentation.</p><footer class=article-meta><time datetime=2019-09-19T12:00:00Z>September 19, 2019</time><span class=tag>go</span><span class=tag>github actions</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/go-http-headers/>Go's net/http.Headers</a></h2></header><p>One probably knows that <code>net/http.Headers</code> is no more than <code>map[string][]string</code> with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>type</span> Header <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>][]<span style=color:#2b91af>string</span>

<span style=color:#00f>func</span> (h Header) Add(key, val <span style=color:#2b91af>string</span>) {
    <span style=color:#00f>if</span> val == <span style=color:#a31515>&#34;&#34;</span> {
        <span style=color:#00f>return</span>
    }
    h[key] = append(h[key], val)
}

<span style=color:#00f>func</span> main() {
    h := make(Header)
    h.Add(<span style=color:#a31515>&#34;Host&#34;</span>, <span style=color:#a31515>&#34;example.com&#34;</span>)
    h.Add(<span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;a.example.com&#34;</span>)
    h.Add(<span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;b.example.com&#34;</span>)
}
</code></pre></div><p>From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that're automatically parsed for every incoming request, this bunch of tiny allocations is something we'd like to avoid.</p><p>I was curious to know if Go's standard library cares about that.</p><p>Looking at the implementation of <a href=https://golang.org/pkg/net/textproto/#Reader.ReadMIMEHeader><code>net/textproto.Reader.ReadMIMEHeader()</code></a>, which's used in the standard
HTTP server, or Go 1.13’s new <a href=https://golang.org/pkg/net/http/#Header.Clone><code>net/http.Header.Copy()</code></a>, it turned out they solve the problem quit elegantly.</p><p>We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.</p><p>Knowing that, we can refactor the initial <code>Header.Add</code> as the following:</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#00f>type</span> Header <span style=color:#00f>map</span>[<span style=color:#2b91af>string</span>][]<span style=color:#2b91af>string</span>

<span style=color:#00f>func</span> (h Header) add(vv []<span style=color:#2b91af>string</span>, key, val <span style=color:#2b91af>string</span>) []<span style=color:#2b91af>string</span> {
    <span style=color:#00f>if</span> val == <span style=color:#a31515>&#34;&#34;</span> { <span>·</span><span>·</span><span>·</span> }

    <span style=color:green>// fast path for KV pair of a single value
</span><span style=color:green></span>    <span style=color:#00f>if</span> h[key] == <span style=color:#00f>nil</span> {
        vv = append(vv, value)
        h[key] = vv[:1:1]
        <span style=color:#00f>return</span> vv[1:]
    }

    <span style=color:green>// slow path, when KV pair has two or more values
</span><span style=color:green></span>    h[key] = append(h[key], val)
    <span style=color:#00f>return</span> vv
}

<span style=color:#00f>func</span> main() {
    h := make(Header)
    <span style=color:green>// net/textprotocol pre-counts total number of request&#39;s headers
</span><span style=color:green></span>    <span style=color:green>// to allocate the slice of known capacity
</span><span style=color:green></span>    vv := make([]<span style=color:#2b91af>string</span>, 0)

    vv = h.add(vv, <span style=color:#a31515>&#34;Host&#34;</span>, <span style=color:#a31515>&#34;example.com&#34;</span>)
    vv = h.add(vv, <span style=color:#a31515>&#34;Via&#34;</span>, <span style=color:#a31515>&#34;a.example.com&#34;</span>)
}
</code></pre></div><p>Note that we use <code>vv[:1:1]</code> to create a <a href=https://golang.org/ref/spec#Slice_expressions>subslice of the fixed capacity</a> (length 1, capacity 1).</p><p>If there is a KV-pair that has several values, e.g. &ldquo;Via&rdquo; header, <code>Add</code> will allocate a separate slice for that key, doubling its capacity.</p><footer class=article-meta><time datetime=2019-09-04T12:00:00Z>September 4, 2019</time><span class=tag>go</span><span class=tag>µ-benchmarks</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/hello-world/>Hello World</a></h2></header><p>Let's create a blog. But let's call them &ldquo;notes&rdquo;.</p><p>Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</p><footer class=article-meta><time datetime=2019-09-01T12:00:00Z>September 1, 2019</time></footer></article></main><footer class=main-footer>© 2020 VLDMR</footer></body></html>