<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><title>Notes - Vladimir Varankin</title><style>:root{--background-color: #fff;--text-color: #111;--header-color: #111;--link-color: #0010a1;--link-hover-color: #be0000}@media(prefers-color-scheme:dark){:root{--background-color: #181818;--text-color: #cfcfcf;--header-color: #e5e5e5;--link-color: #55acff;--link-hover-color: #e74242}}body{background:var(--background-color);color:var(--text-color);font-family:Charter,Georgia,serif;font-size:16px;line-height:1.45;margin:8px 12px}h1,h2,h3,h4{color:var(--header-color);font-family:Athelas,Georgia,serif;line-height:1}a{color:#0010a1;color:var(--link-color)}a:hover,a:active{color:#be0000;color:var(--link-hover-color)}pre{line-height:1.3}code{font-family:Menlo,Consolas,monospace;font-size:14px}.main-nav{letter-spacing:.3em;padding-bottom:8px}.main-nav a,.main-nav span{letter-spacing:0}.main-content{max-width:900px}.main-footer{margin:50px 0 0}.article{margin:0 0 50px}.article-meta{font-size:14px;line-height:1}.tag{margin:0 .3em}</style></head><body><nav class=main-nav><a href=/>Vladimir Varankin</a>
<a href=/notes class=item-current>Notes</a>
<a href=https://github.com/narqo>GitHub</a>
<a href=https://twitter.com/tvii>Twitter</a>
<a href=https://keybase.io/varankinv>Keybase</a></nav><main class=main-content><header class=main-head><h1>Notes</h1></header><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/github-actions-and-gopath/>Github Actions and GOPATH</a></h2></header><p>The other day I received my beta access to <a href=https://github.com/features/actions>GitHub Actions</a>. To try them out I picked an existing pet project and created a <em>workflow</em> using a Go project template provided by GitHub. As it&rsquo;s in <em>September 2019</em>, their template defines the sequence of steps: setup Go, checkout code, get dependencies, build. This is not exactly how I used to do it.</p><p>My project is a <em>classic Go service</em> ;) meaning: it uses vendoring and doesn&rsquo;t use Go modules. So no need for &ldquo;get dependencies&rdquo; step. And it requires to be inside the <code>GOPATH</code>. With that, the provided workflow needed some adjustment.</p><p>After some trials and errors, I&rsquo;ve managed to make <code>checkout</code> step to clone the repo into the correct destination inside the <code>GOPATH</code>. Here is the final workflow:</p><pre><code class=language-yaml>name: Run Go test
on: [pull_request]
jobs:
  test:
    strategy:
      matrix:
        go-version: [1.12.9]

    runs-on: ubuntu-latest

    steps:
      - uses: actions/setup-go@v1
        with:
          go-version: ${{ matrix.go-version }}

      - uses: actions/checkout@v1
        with:
          path: ./src/github.com/${{ github.repository }}
          fetch-depth: 5

      - run: make test
        env:
          GOPATH: ${{ runner.workspace }}
</code></pre><p>Note, how <code>actions/checkout@v1</code> above uses custom <code>path</code> input parameter. I set the path to <code>./src/github.com/${{ github.repository }}</code>, so the project is checked out to <code>src</code> directory in the runners&rsquo;s workspace, which I later pass as the value of <code>GOPATH</code> to the &ldquo;make test&rdquo; step. The leading dot in <code>./src</code> seems very important — I&rsquo;ve spent the majority of the time trying to figure out that part — refer to <a href=https://github.com/actions/checkout/issues/41>this issue</a>.</p><p><a href=https://github.com/profefe/profefe/actions>See the workflow in action</a>.</p><p>To learn more about those <code>${{ ··· }}</code> &ldquo;macroses&rdquo; I suggest looking at the Actions&rsquo; &ldquo;<a href=https://help.github.com/en/articles/contexts-and-expression-syntax-for-github-actions>Contexts and expression syntax</a>&rdquo; documentation.</p><footer class=article-meta><time datetime=2019-09-19T12:00:00Z>September 19, 2019</time>
<span class=tag>golang</span>
<span class=tag>github actions</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/go-http-headers/>Go&#39;s net/http.Headers</a></h2></header><p>One probably knows that <code>net/http.Headers</code> is no more than <code>map[string][]string</code> with extra specific methods. A usual way to initialise and populate such data-structure from an external representation is something like that:</p><pre><code class=language-go>type Header map[string][]string

func (h Header) Add(key, val string) {
    if val == &quot;&quot; {
        return
    }
    h[key] = append(h[key], val)
}

func main() {
    h := make(Header)
    h.Add(&quot;Host&quot;, &quot;example.com&quot;)
    h.Add(&quot;Via&quot;, &quot;a.example.com&quot;)
    h.Add(&quot;Via&quot;, &quot;b.example.com&quot;)
}
</code></pre><p>From the code above, one can notice that we allocated a new slice of strings for every unique key that we added to headers. For things like HTTP headers, that&rsquo;re automatically parsed for every incoming request, this bunch of tiny allocations is something we&rsquo;d like to avoid.</p><p>I was curious to know if Go&rsquo;s standard library cares about that.</p><p>Looking at the implementation of <a href=https://golang.org/pkg/net/textproto/#Reader.ReadMIMEHeader><code>net/textproto.Reader.ReadMIMEHeader()</code></a>, which&rsquo;s used in the standard
HTTP server, or Go 1.13’s new <a href=https://golang.org/pkg/net/http/#Header.Clone><code>net/http.Header.Copy()</code></a>, it turned out they solve the problem quit elegantly.</p><p>We know that for a majority of cases, HTTP headers are an immutable key-value pair, where most of the keys have a single value. Instead of allocating a separate slice for a unique key, Go pre-allocates a continues slice for values and refers to a sub-slice of this slice for all keys.</p><p>Knowing that, we can refactor the initial <code>Header.Add</code> as the following:</p><pre><code class=language-go>type Header map[string][]string

func (h Header) add(vv []string, key, val string) []string {
    if val == &quot;&quot; { ··· }

    // fast path for KV pair of a single value
    if h[key] == nil {
        vv = append(vv, value)
        h[key] = vv[:1:1]
        return vv[1:]
    }

    // slow path, when KV pair has two or more values
    h[key] = append(h[key], val)
    return vv
}

func main() {
    h := make(Header)
    // net/textprotocol pre-counts total number of request's headers
    // to allocate the slice of known capacity
    vv := make([]string, 0)

    vv = h.add(vv, &quot;Host&quot;, &quot;example.com&quot;)
    vv = h.add(vv, &quot;Via&quot;, &quot;a.example.com&quot;)
}
</code></pre><p>Note that we use <code>vv[:1:1]</code> to create a <a href=https://golang.org/ref/spec#Slice_expressions>subslice of the fixed capacity</a> (length 1, capacity 1).</p><p>If there is a KV-pair that has several values, e.g. &ldquo;Via&rdquo; header, <code>Add</code> will allocate a separate slice for that key, doubling its capacity.</p><footer class=article-meta><time datetime=2019-09-04T12:00:00Z>September 4, 2019</time>
<span class=tag>golang</span></footer></article><article class=article data-weight=0><header class=article-head><h2><a href=/notes/2019/09/hello-world/>Hello World</a></h2></header><p>Let&rsquo;s create a blog. But let&rsquo;s call them &ldquo;notes&rdquo;.</p><p>Because sometimes there are thoughts I want to share with you. Some of them might even be larger than a tweet.</p><footer class=article-meta><time datetime=2019-09-01T12:00:00Z>September 1, 2019</time></footer></article></main><footer class=main-footer>© 2019 VLDMR</footer></body></html>