<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux on Vladimir Varankin</title><link>https://vladimir.varank.in/notes/linux/</link><description>Recent content in Linux on Vladimir Varankin</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 12 Jan 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://vladimir.varank.in/notes/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Go runtime vs CFS quota</title><link>https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/</link><pubDate>Thu, 12 Jan 2023 00:00:00 +0000</pubDate><guid>https://vladimir.varank.in/notes/2023/01/go-runtime-vs-cfs-quota/</guid><description>&lt;p>As of today, the Go runtime isn&amp;rsquo;t aware if it runs inside a container under the resource constraints (CPU or memory). The runtime sees the resources available for the container&amp;rsquo;s underlying host OS, e.g. the VM where the container runs, and tries to optimize its behaviour base on what it sees. For container runtimes on Linux, which implements the CPU restrictions via CFS (&amp;ldquo;Completely Fair Scheduler&amp;rdquo;), a mismatch in what the application thinks is has, and what the OS allows to use, can lead to the poor performance of the application after the unexpected throttling.&lt;/p>
&lt;p>For example, a Go application, that runs in a container, constrained with 0.5 CPU, running on a host with 2 CPU, will observe 2 available CPU cores. That is the application&amp;rsquo;s calls to &lt;a href="https://pkg.go.dev/runtime#NumCPU">&lt;code>runtime.NumCPU()&lt;/code>&lt;/a> and &lt;a href="https://pkg.go.dev/runtime#GOMAXPROCS">&lt;code>runtime.GOMAXPROCS()&lt;/code>&lt;/a> will get us &amp;ldquo;2&amp;rdquo;. Because the Go runtime is optimized for the maximum utilization of the available compute under the concurrent workload, the goroutines it spawns are distributed to the internal thread pool, created with the assumption of two available CPU cores. This causes the application to throttle after the sum of the time it spend on the CPU cores per CFS period become equals to the quota of the container. With &lt;a href="https://www.kernel.org/doc/html/latest/scheduler/sched-bwc.html#management">the default CFS period&lt;/a> 100ms, the CFS quota of this container 0.5 CPU, and two threads running on different CPU cores, the application is throttled after 25ms every 100ms.&lt;/p></description></item></channel></rss>